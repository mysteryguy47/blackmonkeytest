"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "(pages-dir-browser)/./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* global location */ // imports polyfill from `@next/polyfill-module` after build.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    emitter: function() {\n        return emitter;\n    },\n    hydrate: function() {\n        return hydrate;\n    },\n    initialize: function() {\n        return initialize;\n    },\n    router: function() {\n        return router;\n    },\n    version: function() {\n        return version;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-runtime.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"));\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(pages-dir-browser)/./node_modules/react-dom/client.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/mitt */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _disablesmoothscroll = __webpack_require__(/*! ../shared/lib/router/utils/disable-smooth-scroll */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _portal = __webpack_require__(/*! ./portal */ \"(pages-dir-browser)/./node_modules/next/dist/client/portal/index.js\");\nconst _headmanager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./head-manager */ \"(pages-dir-browser)/./node_modules/next/dist/client/head-manager.js\"));\nconst _pageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./page-loader */ \"(pages-dir-browser)/./node_modules/next/dist/client/page-loader.js\"));\nconst _routeannouncer = __webpack_require__(/*! ./route-announcer */ \"(pages-dir-browser)/./node_modules/next/dist/client/route-announcer.js\");\nconst _router = __webpack_require__(/*! ./router */ \"(pages-dir-browser)/./node_modules/next/dist/client/router.js\");\nconst _iserror = __webpack_require__(/*! ../lib/is-error */ \"(pages-dir-browser)/./node_modules/next/dist/lib/is-error.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _removebasepath = __webpack_require__(/*! ./remove-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/adapters.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../shared/lib/hooks-client-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(pages-dir-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _tracer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/tracer */ \"(pages-dir-browser)/./node_modules/next/dist/client/tracing/tracer.js\"));\nconst _isnextroutererror = __webpack_require__(/*! ./components/is-next-router-error */ \"(pages-dir-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst version = \"16.0.7\";\nlet router;\nconst emitter = (0, _mitt.default)();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet devClient;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && ((0, _isdynamic.isDynamicRoute)(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + '?' + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { PagesDevOverlayBridge } = __webpack_require__(/*! ../next-devtools/userspace/pages/pages-dev-overlay-setup */ \"(pages-dir-browser)/./node_modules/next/dist/next-devtools/userspace/pages/pages-dev-overlay-setup.js\");\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(PagesDevOverlayBridge, {\n                children: this.props.children\n            });\n        }\n    }\n}\nasync function initialize(opts = {}) {\n    // This makes sure this specific lines are removed in production\n    if (true) {\n        _tracer.default.onSpanEnd((__webpack_require__(/*! ./tracing/report-to-socket */ \"(pages-dir-browser)/./node_modules/next/dist/client/tracing/report-to-socket.js\")[\"default\"]));\n        devClient = opts.devClient;\n    }\n    initialData = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || '';\n    self.__next_set_public_path__(`${prefix}/_next/`);\n    asPath = (0, _utils.getURL)();\n    // make sure not to attempt stripping basePath for 404s\n    if ((0, _hasbasepath.hasBasePath)(asPath)) {\n        asPath = (0, _removebasepath.removeBasePath)(asPath);\n    }\n    if (false) {}\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = __webpack_require__(/*! ./script */ \"(pages-dir-browser)/./node_modules/next/dist/client/script.js\");\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new _pageloader.default(initialData.buildId, prefix);\n    const register = ([r, f])=>pageLoader.routeLoader.onEntrypoint(r, f);\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = (0, _headmanager.default)();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById('__next');\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(App, {\n        ...appProps\n    });\n}\nfunction AppContainer({ children }) {\n    _s();\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = _react.default.useMemo({\n        \"AppContainer.useMemo[adaptedForAppRouter]\": ()=>{\n            return (0, _adapters.adaptForAppRouterInstance)(router);\n        }\n    }[\"AppContainer.useMemo[adaptedForAppRouter]\"], []);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(Container, {\n        fn: (error)=>renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error('Error rendering page: ', err)),\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n            value: adaptedForAppRouter,\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                value: (0, _adapters.adaptForSearchParams)(router),\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_adapters.PathnameContextProviderAdapter, {\n                    router: router,\n                    isAutoExport: self.__NEXT_DATA__.autoExport ?? false,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                        value: (0, _adapters.adaptForPathParams)(router),\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routercontextsharedruntime.RouterContext.Provider, {\n                            value: (0, _router.makePublicRouterInstance)(router),\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n                                value: headManager,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_imageconfigcontextsharedruntime.ImageConfigContext.Provider, {\n                                    value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[32,48,64,96,128,256,384],\"qualities\":[75,70,70,70],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"localPatterns\":[{\"pathname\":\"**\",\"search\":\"\"}]},\n                                    children: children\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n}\n_s(AppContainer, \"F6BSfrFQNeqenuPnUMVY/6gI8uE=\");\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(AppContainer, {\n            children: renderApp(App, appProps)\n        });\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        devClient.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(`A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred`);\n    return pageLoader.loadPage('/_error').then(({ page: ErrorComponent, styleSheets })=>{\n        return lastAppProps?.Component === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_error */ \"(pages-dir-browser)/./node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_app */ \"(pages-dir-browser)/./node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then(({ ErrorComponent, styleSheets })=>{\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(renderErrorProps.props?.err ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then((initProps)=>doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head({ callback }) {\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect({\n        \"Head.useLayoutEffect\": ()=>callback()\n    }[\"Head.useLayoutEffect\"], [\n        callback\n    ]);\n    return null;\n}\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nconst performanceMarks = {\n    navigationStart: 'navigationStart',\n    beforeRender: 'beforeRender',\n    afterRender: 'afterRender',\n    afterHydrate: 'afterHydrate',\n    routeChange: 'routeChange'\n};\nconst performanceMeasures = {\n    hydration: 'Next.js-hydration',\n    beforeHydration: 'Next.js-before-hydration',\n    routeChangeToRender: 'Next.js-route-change-to-render',\n    render: 'Next.js-render'\n};\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    ;\n    [\n        performanceMarks.beforeRender,\n        performanceMarks.afterHydrate,\n        performanceMarks.afterRender,\n        performanceMarks.routeChange\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterHydrate) // mark end of hydration\n    ;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        const beforeHydrationMeasure = performance.measure(performanceMeasures.beforeHydration, performanceMarks.navigationStart, performanceMarks.beforeRender);\n        const hydrationMeasure = performance.measure(performanceMeasures.hydration, performanceMarks.beforeRender, performanceMarks.afterHydrate);\n        if ( true && // Old versions of Safari don't return `PerformanceMeasure`s from `performance.measure()`\n        beforeHydrationMeasure && hydrationMeasure) {\n            _tracer.default.startSpan('navigation-to-hydration', {\n                startTime: performance.timeOrigin + beforeHydrationMeasure.startTime,\n                attributes: {\n                    pathname: location.pathname,\n                    query: location.search\n                }\n            }).end(performance.timeOrigin + hydrationMeasure.startTime + hydrationMeasure.duration);\n        }\n    }\n    if (onPerfEntry) {\n        performance.getEntriesByName(performanceMeasures.hydration).forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterRender) // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(performanceMarks.routeChange, 'mark');\n    if (!navStartEntries.length) return;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        performance.measure(performanceMeasures.routeChangeToRender, navStartEntries[0].name, performanceMarks.beforeRender);\n        performance.measure(performanceMeasures.render, performanceMarks.beforeRender, performanceMarks.afterRender);\n        if (onPerfEntry) {\n            performance.getEntriesByName(performanceMeasures.render).forEach(onPerfEntry);\n            performance.getEntriesByName(performanceMeasures.routeChangeToRender).forEach(onPerfEntry);\n        }\n    }\n    clearMarks();\n    [\n        performanceMeasures.routeChangeToRender,\n        performanceMeasures.render\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(performanceMarks.beforeRender);\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl, {\n            onRecoverableError: _onrecoverableerror.onRecoverableError\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root({ callbacks, children }) {\n    _s2();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect({\n        \"Root.useLayoutEffect\": ()=>callbacks.forEach({\n                \"Root.useLayoutEffect\": (callback)=>callback()\n            }[\"Root.useLayoutEffect\"])\n    }[\"Root.useLayoutEffect\"], [\n        callbacks\n    ]);\n    if (false) {}\n    return children;\n}\n_s2(Root, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = 'initial' in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = Object.defineProperty(new Error('Cancel rendering route'), \"__NEXT_ERROR_CODE\", {\n                value: \"E503\",\n                enumerable: false,\n                configurable: true\n            });\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== 'production') {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute('data-n-href')));\n        const noscript = document.querySelector('noscript[data-n-css]');\n        const nonce = noscript?.getAttribute('data-n-css');\n        styleSheets.forEach(({ href, text })=>{\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement('style');\n                styleTag.setAttribute('data-n-href', href);\n                styleTag.setAttribute('media', 'x');\n                if (nonce) {\n                    styleTag.setAttribute('nonce', nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (false) {}\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n                callback: onHeadCommit\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(AppContainer, {\n                children: [\n                    renderApp(App, appProps),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_portal.Portal, {\n                        type: \"next-route-announcer\",\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routeannouncer.RouteAnnouncer, {})\n                    })\n                ]\n            })\n        ]\n    });\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ],\n            children:  true ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.default.StrictMode, {\n                children: elem\n            }) : 0\n        }));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    // if an error occurs in a server-side page (e.g. in getInitialProps),\n    // skip re-rendering the error page client-side as data-fetching operations\n    // will already have been done on the server and NEXT_DATA contains the correct\n    // data for straight-forward hydration of the error page\n    if (renderingProps.err && // renderingProps.Component might be undefined if there is a top/module-level error\n    (typeof renderingProps.Component === 'undefined' || !renderingProps.isHydratePass)) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = (0, _iserror.getProperError)(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (true) {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nasync function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint('/_app');\n        if ('error' in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = ({ id, name, startTime, value, duration, entryType, entries, attribution })=>{\n                // Combines timestamp with random number for unique ID\n                const uniqueID = `${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n         true && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if ('error' in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (true) {\n            const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/react-is/index.js\");\n            if (!isValidElementType(CachedComponent)) {\n                throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"${initialData.page}\"`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E286\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = (0, _iserror.getProperError)(error);\n    }\n    if (true) {\n        const getServerError = (__webpack_require__(/*! ../server/dev/node-stack-frames */ \"(pages-dir-browser)/./node_modules/next/dist/server/dev/node-stack-frames.js\").getServerError);\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw Object.defineProperty(new Error(initialErr.message), \"__NEXT_ERROR_CODE\", {\n                            value: \"E394\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    const errSource = initialErr.source;\n                    // In development, error the navigation API usage in runtime,\n                    // since it's not allowed to be used in pages router as it doesn't contain error boundary like app router.\n                    if ((0, _isnextroutererror.isNextRouterError)(initialErr)) {\n                        error.message = 'Next.js navigation API is not allowed to be used in Pages Router.';\n                    }\n                    throw getServerError(error, errSource);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = (0, _router.createRouter)(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr,\n        isHydratePass: true\n    };\n    if (opts?.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixHQUNuQiw2REFBNkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5RWhEQSxPQUFPO2VBQVBBOztJQXF2QlNDLE9BQU87ZUFBUEE7O0lBbG9CQUMsVUFBVTtlQUFWQTs7SUFwSFhDLE1BQU07ZUFBTkE7O0lBREVDLE9BQU87ZUFBUEE7Ozs7O29CQXRFTjs0RUFReUI7NkVBQ1g7NkRBQ2M7MkVBQ2xCO3dEQUVhO2lEQUMyQjt1Q0FDMUI7eUNBSXhCO21DQUN5QztvQ0FFekI7a0ZBQ0s7aUZBQ0w7NENBRVE7b0NBQ3dCO3FDQUN4Qjs2REFDSTs0Q0FFSjt5Q0FDSDsyREFDSztzQ0FNMUI7NkRBSUE7Z0RBQzRCOzZFQUNoQjsrQ0FDZTtBQXdCM0IsTUFBTUEsVUFBVUMsUUFBUUM7QUFDeEIsSUFBSUg7QUFDSixNQUFNSCxVQUErQlEsQ0FBQUEsR0FBQUEsTUFBQUEsT0FBQUE7QUFFNUMsTUFBTUMsZUFBZSxDQUFlQyxRQUFvQixFQUFFLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDRjtBQUV0RSxJQUFJRztBQUNKLElBQUlDLGdCQUFvQ0M7QUFDeEMsSUFBSUM7QUFDSixJQUFJQztBQUNKLElBQUlDO0FBQ0osSUFBSUM7QUFLSixJQUFJQywyQkFBMkI7QUFDL0IsSUFBSUM7QUFFSixJQUFJQztBQUNKLElBQUlDO0FBRUosSUFBSUMsV0FBeUJDO0FBQzdCLElBQUlDO0FBRUosTUFBTUMsa0JBQWtCQyxPQUFBQSxPQUFLLENBQUNDLFNBQVM7SUFJckNDLGtCQUFrQkMsWUFBbUIsRUFBRUMsSUFBUyxFQUFFO1FBQ2hELElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxFQUFFLENBQUNILGNBQWNDO0lBQzlCO0lBRUFHLG9CQUFvQjtRQUNsQixJQUFJLENBQUNDLFlBQVk7UUFFakIsMENBQTBDO1FBQzFDLHlFQUF5RTtRQUN6RSxvRUFB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Y2VzQ29udGVudCI6WyIvKiBnbG9iYWwgbG9jYXRpb24gKi9cbi8vIGltcG9ydHMgcG9seWZpbGwgZnJvbSBgQG5leHQvcG9seWZpbGwtbW9kdWxlYCBhZnRlciBidWlsZC5cbmltcG9ydCAnLi4vYnVpbGQvcG9seWZpbGxzL3BvbHlmaWxsLW1vZHVsZSdcbmltcG9ydCB0eXBlIFJvdXRlciBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgdHlwZSB7XG4gIEFwcENvbXBvbmVudCxcbiAgQXBwUHJvcHMsXG4gIFByaXZhdGVSb3V0ZUluZm8sXG59IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlcidcblxuaW1wb3J0IFJlYWN0LCB7IHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tL2NsaWVudCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgbWl0dCBmcm9tICcuLi9zaGFyZWQvbGliL21pdHQnXG5pbXBvcnQgdHlwZSB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9taXR0J1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZGlzYWJsZS1zbW9vdGgtc2Nyb2xsJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHtcbiAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyxcbiAgYXNzaWduLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZydcbmltcG9ydCB7IGdldFVSTCwgbG9hZEdldEluaXRpYWxQcm9wcywgU1QgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzJ1xuaW1wb3J0IHR5cGUgeyBOZXh0V2ViVml0YWxzTWV0cmljLCBORVhUX0RBVEEgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzJ1xuaW1wb3J0IHsgUG9ydGFsIH0gZnJvbSAnLi9wb3J0YWwnXG5pbXBvcnQgaW5pdEhlYWRNYW5hZ2VyIGZyb20gJy4vaGVhZC1tYW5hZ2VyJ1xuaW1wb3J0IFBhZ2VMb2FkZXIgZnJvbSAnLi9wYWdlLWxvYWRlcidcbmltcG9ydCB0eXBlIHsgU3R5bGVTaGVldFR1cGxlIH0gZnJvbSAnLi9wYWdlLWxvYWRlcidcbmltcG9ydCB7IFJvdXRlQW5ub3VuY2VyIH0gZnJvbSAnLi9yb3V0ZS1hbm5vdW5jZXInXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXIsIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgZ2V0UHJvcGVyRXJyb3IgfSBmcm9tICcuLi9saWIvaXMtZXJyb3InXG5pbXBvcnQgeyBJbWFnZUNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBJbWFnZUNvbmZpZ0NvbXBsZXRlIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyByZW1vdmVCYXNlUGF0aCB9IGZyb20gJy4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgQXBwUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHtcbiAgYWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgYWRhcHRGb3JQYXRoUGFyYW1zLFxuICBhZGFwdEZvclNlYXJjaFBhcmFtcyxcbiAgUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci9hZGFwdGVycydcbmltcG9ydCB7XG4gIFNlYXJjaFBhcmFtc0NvbnRleHQsXG4gIFBhdGhQYXJhbXNDb250ZXh0LFxufSBmcm9tICcuLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgb25SZWNvdmVyYWJsZUVycm9yIH0gZnJvbSAnLi9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL29uLXJlY292ZXJhYmxlLWVycm9yJ1xuaW1wb3J0IHRyYWNlciBmcm9tICcuL3RyYWNpbmcvdHJhY2VyJ1xuaW1wb3J0IHsgaXNOZXh0Um91dGVyRXJyb3IgfSBmcm9tICcuL2NvbXBvbmVudHMvaXMtbmV4dC1yb3V0ZXItZXJyb3InXG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwicmVhY3QtZG9tL2V4cGVyaW1lbnRhbFwiIC8+XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgLyogdGVzdCBmbnMgKi9cbiAgICBfX05FWFRfSFlEUkFURUQ/OiBib29sZWFuXG4gICAgX19ORVhUX0hZRFJBVEVEX0FUPzogbnVtYmVyXG4gICAgX19ORVhUX0hZRFJBVEVEX0NCPzogKCkgPT4gdm9pZFxuXG4gICAgLyogcHJvZCAqL1xuICAgIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICAgIF9fTkVYVF9QOiBhbnlbXVxuICB9XG59XG50eXBlIFJlbmRlclJvdXRlSW5mbyA9IFByaXZhdGVSb3V0ZUluZm8gJiB7XG4gIEFwcDogQXBwQ29tcG9uZW50XG4gIHNjcm9sbD86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbiAgaXNIeWRyYXRlUGFzcz86IGJvb2xlYW5cbn1cbnR5cGUgUmVuZGVyRXJyb3JQcm9wcyA9IE9taXQ8UmVuZGVyUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdzdHlsZVNoZWV0cyc+XG50eXBlIFJlZ2lzdGVyRm4gPSAoaW5wdXQ6IFtzdHJpbmcsICgpID0+IHZvaWRdKSA9PiB2b2lkXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1ZFUlNJT05cbmV4cG9ydCBsZXQgcm91dGVyOiBSb3V0ZXJcbmV4cG9ydCBjb25zdCBlbWl0dGVyOiBNaXR0RW1pdHRlcjxzdHJpbmc+ID0gbWl0dCgpXG5cbmNvbnN0IGxvb3NlVG9BcnJheSA9IDxUIGV4dGVuZHMge30+KGlucHV0OiBhbnkpOiBUW10gPT4gW10uc2xpY2UuY2FsbChpbnB1dClcblxubGV0IGluaXRpYWxEYXRhOiBORVhUX0RBVEFcbmxldCBkZWZhdWx0TG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbmxldCBhc1BhdGg6IHN0cmluZ1xubGV0IHBhZ2VMb2FkZXI6IFBhZ2VMb2FkZXJcbmxldCBhcHBFbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGxcbmxldCBoZWFkTWFuYWdlcjoge1xuICBtb3VudGVkSW5zdGFuY2VzOiBTZXQ8dW5rbm93bj5cbiAgdXBkYXRlSGVhZDogKGhlYWQ6IEpTWC5FbGVtZW50W10pID0+IHZvaWRcbiAgZ2V0SXNTc3I/OiAoKSA9PiBib29sZWFuXG59XG5sZXQgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlID0gZmFsc2VcbmxldCBsYXN0QXBwUHJvcHM6IEFwcFByb3BzXG5cbmxldCBsYXN0UmVuZGVyUmVqZWN0OiAoKCkgPT4gdm9pZCkgfCBudWxsXG5sZXQgZGV2Q2xpZW50OiBhbnlcblxubGV0IENhY2hlZEFwcDogQXBwQ29tcG9uZW50LCBvblBlcmZFbnRyeTogKG1ldHJpYzogYW55KSA9PiB2b2lkXG5sZXQgQ2FjaGVkQ29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlXG5cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlXG4gIGZuOiAoZXJyOiBFcnJvciwgaW5mbz86IGFueSkgPT4gdm9pZFxufT4ge1xuICBjb21wb25lbnREaWRDYXRjaChjb21wb25lbnRFcnI6IEVycm9yLCBpbmZvOiBhbnkpIHtcbiAgICB0aGlzLnByb3BzLmZuKGNvbXBvbmVudEVyciwgaW5mbylcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2Nyb2xsVG9IYXNoKClcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuICAgIC8vIC0gdGhlIHBhZ2Ugd2FzIChhdXRvKSBleHBvcnRlZCBhbmQgaGFzIGEgcXVlcnkgc3RyaW5nIG9yIHNlYXJjaCAoaGFzaClcbiAgICAvLyAtIGl0IHdhcyBhdXRvIGV4cG9ydGVkIGFuZCBpcyBhIGR5bmFtaWMgcm91dGUgKHRvIHByb3ZpZGUgcGFyYW1zKVxuICAgIC8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuICAgIC8vIC0gaWYgbWlkZGxld2FyZSBtYXRjaGVzIHRoZSBjdXJyZW50IHBhZ2UgKG1heSBoYXZlIHJld3JpdGUgcGFyYW1zKVxuICAgIC8vIC0gaWYgcmV3cml0ZXMgaW4gbmV4dC5jb25maWcuanMgbWF0Y2ggKG1heSBoYXZlIHJld3JpdGUgcGFyYW1zKVxuICAgIGlmIChcbiAgICAgIHJvdXRlci5pc1NzciAmJlxuICAgICAgKGluaXRpYWxEYXRhLmlzRmFsbGJhY2sgfHxcbiAgICAgICAgKGluaXRpYWxEYXRhLm5leHRFeHBvcnQgJiZcbiAgICAgICAgICAoaXNEeW5hbWljUm91dGUocm91dGVyLnBhdGhuYW1lKSB8fFxuICAgICAgICAgICAgbG9jYXRpb24uc2VhcmNoIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8XG4gICAgICAgICAgICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpKSB8fFxuICAgICAgICAoaW5pdGlhbERhdGEucHJvcHMgJiZcbiAgICAgICAgICBpbml0aWFsRGF0YS5wcm9wcy5fX05fU1NHICYmXG4gICAgICAgICAgKGxvY2F0aW9uLnNlYXJjaCB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyB8fFxuICAgICAgICAgICAgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlKSkpXG4gICAgKSB7XG4gICAgICAvLyB1cGRhdGUgcXVlcnkgb24gbW91bnQgZm9yIGV4cG9ydGVkIHBhZ2VzXG4gICAgICByb3V0ZXJcbiAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgcm91dGVyLnBhdGhuYW1lICtcbiAgICAgICAgICAgICc/JyArXG4gICAgICAgICAgICBTdHJpbmcoXG4gICAgICAgICAgICAgIGFzc2lnbihcbiAgICAgICAgICAgICAgICB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHJvdXRlci5xdWVyeSksXG4gICAgICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbiAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAgICAvLyBJdCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICAgICAgX2g6IDEsXG4gICAgICAgICAgICAvLyBGYWxsYmFjayBwYWdlcyBtdXN0IHRyaWdnZXIgdGhlIGRhdGEgZmV0Y2gsIHNvIHRoZSB0cmFuc2l0aW9uIGlzXG4gICAgICAgICAgICAvLyBub3Qgc2hhbGxvdy5cbiAgICAgICAgICAgIC8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbiAgICAgICAgICAgIC8vIHJlcXVpcmVtZW50cyB3b3VsZCBhbHJlYWR5IGJlIHByZXNlbnQuXG4gICAgICAgICAgICBzaGFsbG93OiAhaW5pdGlhbERhdGEuaXNGYWxsYmFjayAmJiAhaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlLFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghZXJyLmNhbmNlbGxlZCkgdGhyb3cgZXJyXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuc2Nyb2xsVG9IYXNoKClcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaCgpIHtcbiAgICBsZXQgeyBoYXNoIH0gPSBsb2NhdGlvblxuICAgIGhhc2ggPSBoYXNoICYmIGhhc2guc3Vic3RyaW5nKDEpXG4gICAgaWYgKCFoYXNoKSByZXR1cm5cblxuICAgIGNvbnN0IGVsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKVxuICAgIGlmICghZWwpIHJldHVyblxuXG4gICAgLy8gSWYgd2UgY2FsbCBzY3JvbGxJbnRvVmlldygpIGluIGhlcmUgd2l0aG91dCBhIHNldFRpbWVvdXRcbiAgICAvLyBpdCB3b24ndCBzY3JvbGwgcHJvcGVybHkuXG4gICAgc2V0VGltZW91dCgoKSA9PiBlbC5zY3JvbGxJbnRvVmlldygpLCAwKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IFBhZ2VzRGV2T3ZlcmxheUJyaWRnZSB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvcGFnZXMvcGFnZXMtZGV2LW92ZXJsYXktc2V0dXAnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9wYWdlcy9wYWdlcy1kZXYtb3ZlcmxheS1zZXR1cCcpXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UGFnZXNEZXZPdmVybGF5QnJpZGdlPnt0aGlzLnByb3BzLmNoaWxkcmVufTwvUGFnZXNEZXZPdmVybGF5QnJpZGdlPlxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZShvcHRzOiB7IGRldkNsaWVudD86IGFueSB9ID0ge30pOiBQcm9taXNlPHtcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xufT4ge1xuICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhpcyBzcGVjaWZpYyBsaW5lcyBhcmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIHRyYWNlci5vblNwYW5FbmQoXG4gICAgICAoXG4gICAgICAgIHJlcXVpcmUoJy4vdHJhY2luZy9yZXBvcnQtdG8tc29ja2V0JykgYXMgdHlwZW9mIGltcG9ydCgnLi90cmFjaW5nL3JlcG9ydC10by1zb2NrZXQnKVxuICAgICAgKS5kZWZhdWx0XG4gICAgKVxuICAgIGRldkNsaWVudCA9IG9wdHMuZGV2Q2xpZW50XG4gIH1cblxuICBpbml0aWFsRGF0YSA9IEpTT04ucGFyc2UoXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fTkVYVF9EQVRBX18nKSEudGV4dENvbnRlbnQhXG4gIClcbiAgd2luZG93Ll9fTkVYVF9EQVRBX18gPSBpbml0aWFsRGF0YVxuXG4gIGRlZmF1bHRMb2NhbGUgPSBpbml0aWFsRGF0YS5kZWZhdWx0TG9jYWxlXG4gIGNvbnN0IHByZWZpeDogc3RyaW5nID0gaW5pdGlhbERhdGEuYXNzZXRQcmVmaXggfHwgJydcbiAgLy8gV2l0aCBkeW5hbWljIGFzc2V0UHJlZml4IGl0J3Mgbm8gbG9uZ2VyIHBvc3NpYmxlIHRvIHNldCBhc3NldFByZWZpeCBhdCB0aGUgYnVpbGQgdGltZVxuICAvLyBTbywgdGhpcyBpcyBob3cgd2UgZG8gaXQgaW4gdGhlIGNsaWVudCBzaWRlIGF0IHJ1bnRpbWVcbiAgOyhzZWxmIGFzIGFueSkuX19uZXh0X3NldF9wdWJsaWNfcGF0aF9fKGAke3ByZWZpeH0vX25leHQvYClcblxuICBhc1BhdGggPSBnZXRVUkwoKVxuXG4gIC8vIG1ha2Ugc3VyZSBub3QgdG8gYXR0ZW1wdCBzdHJpcHBpbmcgYmFzZVBhdGggZm9yIDQwNHNcbiAgaWYgKGhhc0Jhc2VQYXRoKGFzUGF0aCkpIHtcbiAgICBhc1BhdGggPSByZW1vdmVCYXNlUGF0aChhc1BhdGgpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIGNvbnN0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJylcblxuICAgIGNvbnN0IHsgZGV0ZWN0RG9tYWluTG9jYWxlIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJylcblxuICAgIGNvbnN0IHsgcGFyc2VSZWxhdGl2ZVVybCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCcpXG5cbiAgICBjb25zdCB7IGZvcm1hdFVybCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJylcblxuICAgIGlmIChpbml0aWFsRGF0YS5sb2NhbGVzKSB7XG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKVxuICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICBpbml0aWFsRGF0YS5sb2NhbGVzXG4gICAgICApXG5cbiAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZVxuICAgICAgICBhc1BhdGggPSBmb3JtYXRVcmwocGFyc2VkQXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZXJpdmUgdGhlIGRlZmF1bHQgbG9jYWxlIGlmIGl0IHdhc24ndCBkZXRlY3RlZCBpbiB0aGUgYXNQYXRoXG4gICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IHByZXJlbmRlciBzdGF0aWMgcGFnZXMgd2l0aCBhbGwgcG9zc2libGUgZGVmYXVsdFxuICAgICAgICAvLyBsb2NhbGVzXG4gICAgICAgIGRlZmF1bHRMb2NhbGUgPSBpbml0aWFsRGF0YS5sb2NhbGVcbiAgICAgIH1cblxuICAgICAgLy8gYXR0ZW1wdCBkZXRlY3RpbmcgZGVmYXVsdCBsb2NhbGUgYmFzZWQgb24gaG9zdG5hbWVcbiAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKFxuICAgICAgICBwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9ET01BSU5TIGFzIGFueSxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lXG4gICAgICApXG5cbiAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIGlmIGRlZmF1bHRMb2NhbGUgbmVlZHMgdG8gYmUgcG9wdWxhdGVkIGFmdGVyXG4gICAgICAvLyBoeWRyYXRpb24gdG8gcHJldmVudCBtaXNtYXRjaGVkIHJlbmRlcnNcbiAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICBkZWZhdWx0TG9jYWxlID0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbml0aWFsRGF0YS5zY3JpcHRMb2FkZXIpIHtcbiAgICBjb25zdCB7IGluaXRTY3JpcHRMb2FkZXIgfSA9XG4gICAgICByZXF1aXJlKCcuL3NjcmlwdCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4vc2NyaXB0JylcbiAgICBpbml0U2NyaXB0TG9hZGVyKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcilcbiAgfVxuXG4gIHBhZ2VMb2FkZXIgPSBuZXcgUGFnZUxvYWRlcihpbml0aWFsRGF0YS5idWlsZElkLCBwcmVmaXgpXG5cbiAgY29uc3QgcmVnaXN0ZXI6IFJlZ2lzdGVyRm4gPSAoW3IsIGZdKSA9PlxuICAgIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIub25FbnRyeXBvaW50KHIsIGYpXG4gIGlmICh3aW5kb3cuX19ORVhUX1ApIHtcbiAgICAvLyBEZWZlciBwYWdlIHJlZ2lzdHJhdGlvbiBmb3IgYW5vdGhlciB0aWNrLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGxcbiAgICAvLyBsYXRlbmN5IGluIGh5ZHJhdGluZyB0aGUgcGFnZSwgYnV0IHJlZHVjZSB0aGUgdG90YWwgYmxvY2tpbmcgdGltZS5cbiAgICB3aW5kb3cuX19ORVhUX1AubWFwKChwKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlZ2lzdGVyKHApLCAwKSlcbiAgfVxuICB3aW5kb3cuX19ORVhUX1AgPSBbXVxuICA7KHdpbmRvdy5fX05FWFRfUCBhcyBhbnkpLnB1c2ggPSByZWdpc3RlclxuXG4gIGhlYWRNYW5hZ2VyID0gaW5pdEhlYWRNYW5hZ2VyKClcbiAgaGVhZE1hbmFnZXIuZ2V0SXNTc3IgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHJvdXRlci5pc1NzclxuICB9XG5cbiAgYXBwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQnKVxuICByZXR1cm4geyBhc3NldFByZWZpeDogcHJlZml4IH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQXBwKEFwcDogQXBwQ29tcG9uZW50LCBhcHBQcm9wczogQXBwUHJvcHMpIHtcbiAgcmV0dXJuIDxBcHAgey4uLmFwcFByb3BzfSAvPlxufVxuXG5mdW5jdGlvbiBBcHBDb250YWluZXIoe1xuICBjaGlsZHJlbixcbn06IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPHt9Pik6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIC8vIENyZWF0ZSBhIG1lbW9pemVkIHZhbHVlIGZvciBuZXh0L25hdmlnYXRpb24gcm91dGVyIGNvbnRleHQuXG4gIGNvbnN0IGFkYXB0ZWRGb3JBcHBSb3V0ZXIgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gYWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpXG4gIH0sIFtdKVxuICByZXR1cm4gKFxuICAgIDxDb250YWluZXJcbiAgICAgIGZuPXsoZXJyb3IpID0+XG4gICAgICAgIHJlbmRlckVycm9yKHsgQXBwOiBDYWNoZWRBcHAsIGVycjogZXJyb3IgfSkuY2F0Y2goKGVycikgPT5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgcGFnZTogJywgZXJyKVxuICAgICAgICApXG4gICAgICB9XG4gICAgPlxuICAgICAgPEFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2FkYXB0ZWRGb3JBcHBSb3V0ZXJ9PlxuICAgICAgICA8U2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17YWRhcHRGb3JTZWFyY2hQYXJhbXMocm91dGVyKX0+XG4gICAgICAgICAgPFBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlclxuICAgICAgICAgICAgcm91dGVyPXtyb3V0ZXJ9XG4gICAgICAgICAgICBpc0F1dG9FeHBvcnQ9e3NlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0ID8/IGZhbHNlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxQYXRoUGFyYW1zQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17YWRhcHRGb3JQYXRoUGFyYW1zKHJvdXRlcil9PlxuICAgICAgICAgICAgICA8Um91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcil9PlxuICAgICAgICAgICAgICAgIDxIZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2hlYWRNYW5hZ2VyfT5cbiAgICAgICAgICAgICAgICAgIDxJbWFnZUNvbmZpZ0NvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e1xuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52XG4gICAgICAgICAgICAgICAgICAgICAgICAuX19ORVhUX0lNQUdFX09QVFMgYXMgYW55IGFzIEltYWdlQ29uZmlnQ29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICA8L0ltYWdlQ29uZmlnQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgICA8L0hlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgPC9Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgPC9QYXRoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICA8L1BhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlcj5cbiAgICAgICAgPC9TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvQ29udGFpbmVyPlxuICApXG59XG5cbmNvbnN0IHdyYXBBcHAgPVxuICAoQXBwOiBBcHBDb21wb25lbnQpID0+XG4gICh3cmFwcGVkQXBwUHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBKU1guRWxlbWVudCA9PiB7XG4gICAgY29uc3QgYXBwUHJvcHM6IEFwcFByb3BzID0ge1xuICAgICAgLi4ud3JhcHBlZEFwcFByb3BzLFxuICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICBlcnI6IGluaXRpYWxEYXRhLmVycixcbiAgICAgIHJvdXRlcixcbiAgICB9XG4gICAgcmV0dXJuIDxBcHBDb250YWluZXI+e3JlbmRlckFwcChBcHAsIGFwcFByb3BzKX08L0FwcENvbnRhaW5lcj5cbiAgfVxuXG4vLyBUaGlzIG1ldGhvZCBoYW5kbGVzIGFsbCBydW50aW1lIGFuZCBkZWJ1ZyBlcnJvcnMuXG4vLyA0MDQgYW5kIDUwMCBlcnJvcnMgYXJlIHNwZWNpYWwga2luZCBvZiBlcnJvcnNcbi8vIGFuZCB0aGV5IGFyZSBzdGlsbCBoYW5kbGUgdmlhIHRoZSBtYWluIHJlbmRlciBtZXRob2QuXG5mdW5jdGlvbiByZW5kZXJFcnJvcihyZW5kZXJFcnJvclByb3BzOiBSZW5kZXJFcnJvclByb3BzKTogUHJvbWlzZTxhbnk+IHtcbiAgbGV0IHsgQXBwLCBlcnIgfSA9IHJlbmRlckVycm9yUHJvcHNcblxuICAvLyBJbiBkZXZlbG9wbWVudCBydW50aW1lIGVycm9ycyBhcmUgY2F1Z2h0IGJ5IG91ciBvdmVybGF5XG4gIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4gICAgLy8gRklYTUU6IGxldCdzIG1ha2UgdGhpcyByZWNvdmVyYWJsZSAoZXJyb3IgaW4gR0lQIGNsaWVudC10cmFuc2l0aW9uKVxuICAgIGRldkNsaWVudC5vblVucmVjb3ZlcmFibGVFcnJvcigpXG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSA8QXBwPiBzbyB0aGF0IHRoZSBgPFJlYWN0RGV2T3ZlcmxheT5gIGNhblxuICAgIC8vIHJlbmRlciBpdHNlbGYuXG4gICAgcmV0dXJuIGRvUmVuZGVyKHtcbiAgICAgIEFwcDogKCkgPT4gbnVsbCxcbiAgICAgIHByb3BzOiB7fSxcbiAgICAgIENvbXBvbmVudDogKCkgPT4gbnVsbCxcbiAgICAgIHN0eWxlU2hlZXRzOiBbXSxcbiAgICB9KVxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG90aGVyd2lzZSB1c2VycyBjYW4ndCB0cmFjayBkb3duIGlzc3Vlcy5cbiAgY29uc29sZS5lcnJvcihlcnIpXG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgYEEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCwgc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvY2xpZW50LXNpZGUtZXhjZXB0aW9uLW9jY3VycmVkYFxuICApXG5cbiAgcmV0dXJuIHBhZ2VMb2FkZXJcbiAgICAubG9hZFBhZ2UoJy9fZXJyb3InKVxuICAgIC50aGVuKCh7IHBhZ2U6IEVycm9yQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9KSA9PiB7XG4gICAgICByZXR1cm4gbGFzdEFwcFByb3BzPy5Db21wb25lbnQgPT09IEVycm9yQ29tcG9uZW50XG4gICAgICAgID8gaW1wb3J0KCcuLi9wYWdlcy9fZXJyb3InKVxuICAgICAgICAgICAgLnRoZW4oKGVycm9yTW9kdWxlKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBpbXBvcnQoJy4uL3BhZ2VzL19hcHAnKS50aGVuKChhcHBNb2R1bGUpID0+IHtcbiAgICAgICAgICAgICAgICBBcHAgPSBhcHBNb2R1bGUuZGVmYXVsdCBhcyBhbnkgYXMgQXBwQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgcmVuZGVyRXJyb3JQcm9wcy5BcHAgPSBBcHBcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JNb2R1bGVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigobSkgPT4gKHtcbiAgICAgICAgICAgICAgRXJyb3JDb21wb25lbnQ6IG0uZGVmYXVsdCBhcyBSZWFjdC5Db21wb25lbnRUeXBlPHt9PixcbiAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIDogeyBFcnJvckNvbXBvbmVudCwgc3R5bGVTaGVldHMgfVxuICAgIH0pXG4gICAgLnRoZW4oKHsgRXJyb3JDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0pID0+IHtcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgZG8gYSBub3JtYWwgcmVuZGVyIHdpdGggdGhlIGBFcnJvckNvbXBvbmVudGAgYXMgY29tcG9uZW50LlxuICAgICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUgdXBvbiBpbml0aWFsIHJlbmRlciwgd2UgY2FuIHVzZSB0aGUgcHJvcHMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNhbGwgYGdldEluaXRpYWxQcm9wc2Agb24gYEFwcGAgYmVmb3JlIG1vdW50aW5nLlxuICAgICAgY29uc3QgQXBwVHJlZSA9IHdyYXBBcHAoQXBwKVxuICAgICAgY29uc3QgYXBwQ3R4ID0ge1xuICAgICAgICBDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50LFxuICAgICAgICBBcHBUcmVlLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGN0eDoge1xuICAgICAgICAgIGVycixcbiAgICAgICAgICBwYXRobmFtZTogaW5pdGlhbERhdGEucGFnZSxcbiAgICAgICAgICBxdWVyeTogaW5pdGlhbERhdGEucXVlcnksXG4gICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICByZW5kZXJFcnJvclByb3BzLnByb3BzPy5lcnJcbiAgICAgICAgICA/IHJlbmRlckVycm9yUHJvcHMucHJvcHNcbiAgICAgICAgICA6IGxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCBhcHBDdHgpXG4gICAgICApLnRoZW4oKGluaXRQcm9wcykgPT5cbiAgICAgICAgZG9SZW5kZXIoe1xuICAgICAgICAgIC4uLnJlbmRlckVycm9yUHJvcHMsXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgcHJvcHM6IGluaXRQcm9wcyxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxufVxuXG4vLyBEdW1teSBjb21wb25lbnQgdGhhdCB3ZSByZW5kZXIgYXMgYSBjaGlsZCBvZiBSb290IHNvIHRoYXQgd2UgY2FuXG4vLyB0b2dnbGUgdGhlIGNvcnJlY3Qgc3R5bGVzIGJlZm9yZSB0aGUgcGFnZSBpcyByZW5kZXJlZC5cbmZ1bmN0aW9uIEhlYWQoeyBjYWxsYmFjayB9OiB7IGNhbGxiYWNrOiAoKSA9PiB2b2lkIH0pOiBudWxsIHtcbiAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWRcbiAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGUuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBjYWxsYmFjaygpLCBbY2FsbGJhY2tdKVxuICByZXR1cm4gbnVsbFxufVxuXG5jb25zdCBwZXJmb3JtYW5jZU1hcmtzID0ge1xuICBuYXZpZ2F0aW9uU3RhcnQ6ICduYXZpZ2F0aW9uU3RhcnQnLFxuICBiZWZvcmVSZW5kZXI6ICdiZWZvcmVSZW5kZXInLFxuICBhZnRlclJlbmRlcjogJ2FmdGVyUmVuZGVyJyxcbiAgYWZ0ZXJIeWRyYXRlOiAnYWZ0ZXJIeWRyYXRlJyxcbiAgcm91dGVDaGFuZ2U6ICdyb3V0ZUNoYW5nZScsXG59IGFzIGNvbnN0XG5cbmNvbnN0IHBlcmZvcm1hbmNlTWVhc3VyZXMgPSB7XG4gIGh5ZHJhdGlvbjogJ05leHQuanMtaHlkcmF0aW9uJyxcbiAgYmVmb3JlSHlkcmF0aW9uOiAnTmV4dC5qcy1iZWZvcmUtaHlkcmF0aW9uJyxcbiAgcm91dGVDaGFuZ2VUb1JlbmRlcjogJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicsXG4gIHJlbmRlcjogJ05leHQuanMtcmVuZGVyJyxcbn0gYXMgY29uc3RcblxubGV0IHJlYWN0Um9vdDogYW55ID0gbnVsbFxuLy8gT24gaW5pdGlhbCByZW5kZXIgYSBoeWRyYXRlIHNob3VsZCBhbHdheXMgaGFwcGVuXG5sZXQgc2hvdWxkSHlkcmF0ZTogYm9vbGVhbiA9IHRydWVcblxuZnVuY3Rpb24gY2xlYXJNYXJrcygpOiB2b2lkIHtcbiAgO1tcbiAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICBwZXJmb3JtYW5jZU1hcmtzLmFmdGVySHlkcmF0ZSxcbiAgICBwZXJmb3JtYW5jZU1hcmtzLmFmdGVyUmVuZGVyLFxuICAgIHBlcmZvcm1hbmNlTWFya3Mucm91dGVDaGFuZ2UsXG4gIF0uZm9yRWFjaCgobWFyaykgPT4gcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKSlcbn1cblxuZnVuY3Rpb24gbWFya0h5ZHJhdGVDb21wbGV0ZSgpOiB2b2lkIHtcbiAgaWYgKCFTVCkgcmV0dXJuXG5cbiAgcGVyZm9ybWFuY2UubWFyayhwZXJmb3JtYW5jZU1hcmtzLmFmdGVySHlkcmF0ZSkgLy8gbWFyayBlbmQgb2YgaHlkcmF0aW9uXG5cbiAgY29uc3QgaGFzQmVmb3JlUmVuZGVyTWFyayA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsXG4gICAgJ21hcmsnXG4gICkubGVuZ3RoXG4gIGlmIChoYXNCZWZvcmVSZW5kZXJNYXJrKSB7XG4gICAgY29uc3QgYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSA9IHBlcmZvcm1hbmNlLm1lYXN1cmUoXG4gICAgICBwZXJmb3JtYW5jZU1lYXN1cmVzLmJlZm9yZUh5ZHJhdGlvbixcbiAgICAgIHBlcmZvcm1hbmNlTWFya3MubmF2aWdhdGlvblN0YXJ0LFxuICAgICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXJcbiAgICApXG5cbiAgICBjb25zdCBoeWRyYXRpb25NZWFzdXJlID0gcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMuaHlkcmF0aW9uLFxuICAgICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmFmdGVySHlkcmF0ZVxuICAgIClcblxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICAvLyBPbGQgdmVyc2lvbnMgb2YgU2FmYXJpIGRvbid0IHJldHVybiBgUGVyZm9ybWFuY2VNZWFzdXJlYHMgZnJvbSBgcGVyZm9ybWFuY2UubWVhc3VyZSgpYFxuICAgICAgYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSAmJlxuICAgICAgaHlkcmF0aW9uTWVhc3VyZVxuICAgICkge1xuICAgICAgdHJhY2VyXG4gICAgICAgIC5zdGFydFNwYW4oJ25hdmlnYXRpb24tdG8taHlkcmF0aW9uJywge1xuICAgICAgICAgIHN0YXJ0VGltZTogcGVyZm9ybWFuY2UudGltZU9yaWdpbiArIGJlZm9yZUh5ZHJhdGlvbk1lYXN1cmUuc3RhcnRUaW1lLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5OiBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgLmVuZChcbiAgICAgICAgICBwZXJmb3JtYW5jZS50aW1lT3JpZ2luICtcbiAgICAgICAgICAgIGh5ZHJhdGlvbk1lYXN1cmUuc3RhcnRUaW1lICtcbiAgICAgICAgICAgIGh5ZHJhdGlvbk1lYXN1cmUuZHVyYXRpb25cbiAgICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGlmIChvblBlcmZFbnRyeSkge1xuICAgIHBlcmZvcm1hbmNlXG4gICAgICAuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLmh5ZHJhdGlvbilcbiAgICAgIC5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICB9XG4gIGNsZWFyTWFya3MoKVxufVxuXG5mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKTogdm9pZCB7XG4gIGlmICghU1QpIHJldHVyblxuXG4gIHBlcmZvcm1hbmNlLm1hcmsocGVyZm9ybWFuY2VNYXJrcy5hZnRlclJlbmRlcikgLy8gbWFyayBlbmQgb2YgcmVuZGVyXG4gIGNvbnN0IG5hdlN0YXJ0RW50cmllczogUGVyZm9ybWFuY2VFbnRyeUxpc3QgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKFxuICAgIHBlcmZvcm1hbmNlTWFya3Mucm91dGVDaGFuZ2UsXG4gICAgJ21hcmsnXG4gIClcblxuICBpZiAoIW5hdlN0YXJ0RW50cmllcy5sZW5ndGgpIHJldHVyblxuXG4gIGNvbnN0IGhhc0JlZm9yZVJlbmRlck1hcmsgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKFxuICAgIHBlcmZvcm1hbmNlTWFya3MuYmVmb3JlUmVuZGVyLFxuICAgICdtYXJrJ1xuICApLmxlbmd0aFxuXG4gIGlmIChoYXNCZWZvcmVSZW5kZXJNYXJrKSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMucm91dGVDaGFuZ2VUb1JlbmRlcixcbiAgICAgIG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLFxuICAgICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXJcbiAgICApXG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMucmVuZGVyLFxuICAgICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmFmdGVyUmVuZGVyXG4gICAgKVxuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgcGVyZm9ybWFuY2VcbiAgICAgICAgLmdldEVudHJpZXNCeU5hbWUocGVyZm9ybWFuY2VNZWFzdXJlcy5yZW5kZXIpXG4gICAgICAgIC5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICAgICAgcGVyZm9ybWFuY2VcbiAgICAgICAgLmdldEVudHJpZXNCeU5hbWUocGVyZm9ybWFuY2VNZWFzdXJlcy5yb3V0ZUNoYW5nZVRvUmVuZGVyKVxuICAgICAgICAuZm9yRWFjaChvblBlcmZFbnRyeSlcbiAgICB9XG4gIH1cblxuICBjbGVhck1hcmtzKClcbiAgO1tcbiAgICBwZXJmb3JtYW5jZU1lYXN1cmVzLnJvdXRlQ2hhbmdlVG9SZW5kZXIsXG4gICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5yZW5kZXIsXG4gIF0uZm9yRWFjaCgobWVhc3VyZSkgPT4gcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlKSlcbn1cblxuZnVuY3Rpb24gcmVuZGVyUmVhY3RFbGVtZW50KFxuICBkb21FbDogSFRNTEVsZW1lbnQsXG4gIGZuOiAoY2I6ICgpID0+IHZvaWQpID0+IEpTWC5FbGVtZW50XG4pOiB2b2lkIHtcbiAgLy8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuICBpZiAoU1QpIHtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKHBlcmZvcm1hbmNlTWFya3MuYmVmb3JlUmVuZGVyKVxuICB9XG5cbiAgY29uc3QgcmVhY3RFbCA9IGZuKHNob3VsZEh5ZHJhdGUgPyBtYXJrSHlkcmF0ZUNvbXBsZXRlIDogbWFya1JlbmRlckNvbXBsZXRlKVxuICBpZiAoIXJlYWN0Um9vdCkge1xuICAgIC8vIFVubGlrZSB3aXRoIGNyZWF0ZVJvb3QsIHlvdSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgcm9vdC5yZW5kZXIoKSBjYWxsIGhlcmVcbiAgICByZWFjdFJvb3QgPSBSZWFjdERPTS5oeWRyYXRlUm9vdChkb21FbCwgcmVhY3RFbCwge1xuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgIH0pXG4gICAgLy8gVE9ETzogUmVtb3ZlIHNob3VsZEh5ZHJhdGUgdmFyaWFibGUgd2hlbiBSZWFjdCAxOCBpcyBzdGFibGUgYXMgaXQgY2FuIGRlcGVuZCBvbiBgcmVhY3RSb290YCBleGlzdGluZ1xuICAgIHNob3VsZEh5ZHJhdGUgPSBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0YXJ0VHJhbnNpdGlvbiA9IChSZWFjdCBhcyBhbnkpLnN0YXJ0VHJhbnNpdGlvblxuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICByZWFjdFJvb3QucmVuZGVyKHJlYWN0RWwpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBSb290KHtcbiAgY2FsbGJhY2tzLFxuICBjaGlsZHJlbixcbn06IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPHtcbiAgY2FsbGJhY2tzOiBBcnJheTwoKSA9PiB2b2lkPlxufT4pOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFja3MgYXJlIGV4ZWN1dGVkXG4gIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdChcbiAgICAoKSA9PiBjYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpLFxuICAgIFtjYWxsYmFja3NdXG4gIClcblxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEID0gdHJ1ZVxuICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRF9BVCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cbiAgICAgIGlmICh3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKVxuICAgICAgfVxuICAgIH0sIFtdKVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuIGFzIFJlYWN0LlJlYWN0RWxlbWVudFxufVxuXG5mdW5jdGlvbiBkb1JlbmRlcihpbnB1dDogUmVuZGVyUm91dGVJbmZvKTogUHJvbWlzZTxhbnk+IHtcbiAgbGV0IHsgQXBwLCBDb21wb25lbnQsIHByb3BzLCBlcnIgfTogUmVuZGVyUm91dGVJbmZvID0gaW5wdXRcbiAgbGV0IHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXSB8IHVuZGVmaW5lZCA9XG4gICAgJ2luaXRpYWwnIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHNcbiAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnRcbiAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHNcblxuICBjb25zdCBhcHBQcm9wczogQXBwUHJvcHMgPSB7XG4gICAgLi4ucHJvcHMsXG4gICAgQ29tcG9uZW50LFxuICAgIGVycixcbiAgICByb3V0ZXIsXG4gIH1cbiAgLy8gbGFzdEFwcFByb3BzIGhhcyB0byBiZSBzZXQgYmVmb3JlIFJlYWN0RG9tLnJlbmRlciB0byBhY2NvdW50IGZvciBSZWFjdERvbSB0aHJvd2luZyBhbiBlcnJvci5cbiAgbGFzdEFwcFByb3BzID0gYXBwUHJvcHNcblxuICBsZXQgY2FuY2VsZWQ6IGJvb2xlYW4gPSBmYWxzZVxuICBsZXQgcmVzb2x2ZVByb21pc2U6ICgpID0+IHZvaWRcbiAgY29uc3QgcmVuZGVyUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAobGFzdFJlbmRlclJlamVjdCkge1xuICAgICAgbGFzdFJlbmRlclJlamVjdCgpXG4gICAgfVxuICAgIHJlc29sdmVQcm9taXNlID0gKCkgPT4ge1xuICAgICAgbGFzdFJlbmRlclJlamVjdCA9IG51bGxcbiAgICAgIHJlc29sdmUoKVxuICAgIH1cbiAgICBsYXN0UmVuZGVyUmVqZWN0ID0gKCkgPT4ge1xuICAgICAgY2FuY2VsZWQgPSB0cnVlXG4gICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbFxuXG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdDYW5jZWwgcmVuZGVyaW5nIHJvdXRlJylcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHJlamVjdChlcnJvcilcbiAgICB9XG4gIH0pXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgYSByZXR1cm4gdHlwZSB0byBlbnN1cmUgaXQgZG9lc24ndCBzdGFydCByZXR1cm5pbmcgYVxuICAvLyBQcm9taXNlLiBJdCBzaG91bGQgcmVtYWluIHN5bmNocm9ub3VzLlxuICBmdW5jdGlvbiBvblN0YXJ0KCk6IGJvb2xlYW4ge1xuICAgIGlmIChcbiAgICAgICFzdHlsZVNoZWV0cyB8fFxuICAgICAgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3M6IEhUTUxTdHlsZUVsZW1lbnRbXSA9IGxvb3NlVG9BcnJheTxIVE1MU3R5bGVFbGVtZW50PihcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2RhdGEtbi1ocmVmXScpXG4gICAgKVxuICAgIGNvbnN0IGN1cnJlbnRIcmVmczogU2V0PHN0cmluZyB8IG51bGw+ID0gbmV3IFNldChcbiAgICAgIGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpID0+IHRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJykpXG4gICAgKVxuXG4gICAgY29uc3Qgbm9zY3JpcHQ6IEVsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICdub3NjcmlwdFtkYXRhLW4tY3NzXSdcbiAgICApXG4gICAgY29uc3Qgbm9uY2U6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgPVxuICAgICAgbm9zY3JpcHQ/LmdldEF0dHJpYnV0ZSgnZGF0YS1uLWNzcycpXG5cbiAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYsIHRleHQgfTogeyBocmVmOiBzdHJpbmc7IHRleHQ6IGFueSB9KSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRIcmVmcy5oYXMoaHJlZikpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnLCBocmVmKVxuICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKVxuXG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpXG4gICAgICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSGVhZENvbW1pdCgpOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICAvLyBUdXJib3BhY2sgaGFzIGl0J3Mgb3duIGNzcyBpbmplY3Rpb24gaGFuZGxpbmcsIHRoaXMgY29kZSBlbmRzIHVwIHJlbW92aW5nIHRoZSBDU1MuXG4gICAgICAhcHJvY2Vzcy5lbnYuVFVSQk9QQUNLICYmXG4gICAgICAvLyBXZSB1c2UgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgLy8gV2UgY2FuIHNraXAgdGhpcyBkdXJpbmcgaHlkcmF0aW9uLiBSdW5uaW5nIGl0IHdvbnQgY2F1c2UgYW55IGhhcm0sIGJ1dFxuICAgICAgLy8gd2UgbWF5IGFzIHdlbGwgc2F2ZSB0aGUgQ1BVIGN5Y2xlczpcbiAgICAgIHN0eWxlU2hlZXRzICYmXG4gICAgICAvLyBFbnN1cmUgdGhpcyByZW5kZXIgd2FzIG5vdCBjYW5jZWxlZFxuICAgICAgIWNhbmNlbGVkXG4gICAgKSB7XG4gICAgICBjb25zdCBkZXNpcmVkSHJlZnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChzdHlsZVNoZWV0cy5tYXAoKHMpID0+IHMuaHJlZikpXG4gICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzOiBIVE1MU3R5bGVFbGVtZW50W10gPVxuICAgICAgICBsb29zZVRvQXJyYXk8SFRNTFN0eWxlRWxlbWVudD4oXG4gICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJylcbiAgICAgICAgKVxuICAgICAgY29uc3QgY3VycmVudEhyZWZzOiBzdHJpbmdbXSA9IGN1cnJlbnRTdHlsZVRhZ3MubWFwKFxuICAgICAgICAodGFnKSA9PiB0YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpIVxuICAgICAgKVxuXG4gICAgICAvLyBUb2dnbGUgYDxzdHlsZT5gIHRhZ3Mgb24gb3Igb2ZmIGRlcGVuZGluZyBvbiBpZiB0aGV5J3JlIG5lZWRlZDpcbiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGN1cnJlbnRIcmVmcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIGlmIChkZXNpcmVkSHJlZnMuaGFzKGN1cnJlbnRIcmVmc1tpZHhdKSkge1xuICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50U3R5bGVUYWdzW2lkeF0uc2V0QXR0cmlidXRlKCdtZWRpYScsICd4JylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW9yZGVyIHN0eWxlcyBpbnRvIGludGVuZGVkIG9yZGVyOlxuICAgICAgbGV0IHJlZmVyZW5jZU5vZGU6IEVsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgJ25vc2NyaXB0W2RhdGEtbi1jc3NdJ1xuICAgICAgKVxuICAgICAgaWYgKFxuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgIHJlZmVyZW5jZU5vZGVcbiAgICAgICkge1xuICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYgfTogeyBocmVmOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldFRhZzogRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgYHN0eWxlW2RhdGEtbi1ocmVmPVwiJHtocmVmfVwiXWBcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgdGFyZ2V0VGFnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VOb2RlIS5wYXJlbnROb2RlIS5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgIHRhcmdldFRhZyxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSEubmV4dFNpYmxpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSB0YXJnZXRUYWdcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsbHksIGNsZWFuIHVwIHNlcnZlciByZW5kZXJlZCBzdHlsZXNoZWV0czpcbiAgICAgIGxvb3NlVG9BcnJheTxIVE1MTGlua0VsZW1lbnQ+KFxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2RhdGEtbi1wXScpXG4gICAgICApLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUhLnJlbW92ZUNoaWxkKGVsKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuc2Nyb2xsKSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IGlucHV0LnNjcm9sbFxuICAgICAgZGlzYWJsZVNtb290aFNjcm9sbER1cmluZ1JvdXRlVHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJvb3RDb21taXQoKTogdm9pZCB7XG4gICAgcmVzb2x2ZVByb21pc2UoKVxuICB9XG5cbiAgb25TdGFydCgpXG5cbiAgY29uc3QgZWxlbTogSlNYLkVsZW1lbnQgPSAoXG4gICAgPD5cbiAgICAgIDxIZWFkIGNhbGxiYWNrPXtvbkhlYWRDb21taXR9IC8+XG4gICAgICA8QXBwQ29udGFpbmVyPlxuICAgICAgICB7cmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpfVxuICAgICAgICA8UG9ydGFsIHR5cGU9XCJuZXh0LXJvdXRlLWFubm91bmNlclwiPlxuICAgICAgICAgIDxSb3V0ZUFubm91bmNlciAvPlxuICAgICAgICA8L1BvcnRhbD5cbiAgICAgIDwvQXBwQ29udGFpbmVyPlxuICAgIDwvPlxuICApXG5cbiAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gIHJlbmRlclJlYWN0RWxlbWVudChhcHBFbGVtZW50ISwgKGNhbGxiYWNrKSA9PiAoXG4gICAgPFJvb3QgY2FsbGJhY2tzPXtbY2FsbGJhY2ssIG9uUm9vdENvbW1pdF19PlxuICAgICAge3Byb2Nlc3MuZW52Ll9fTkVYVF9TVFJJQ1RfTU9ERSA/IChcbiAgICAgICAgPFJlYWN0LlN0cmljdE1vZGU+e2VsZW19PC9SZWFjdC5TdHJpY3RNb2RlPlxuICAgICAgKSA6IChcbiAgICAgICAgZWxlbVxuICAgICAgKX1cbiAgICA8L1Jvb3Q+XG4gICkpXG5cbiAgcmV0dXJuIHJlbmRlclByb21pc2Vcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzOiBSZW5kZXJSb3V0ZUluZm8pOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gaWYgYW4gZXJyb3Igb2NjdXJzIGluIGEgc2VydmVyLXNpZGUgcGFnZSAoZS5nLiBpbiBnZXRJbml0aWFsUHJvcHMpLFxuICAvLyBza2lwIHJlLXJlbmRlcmluZyB0aGUgZXJyb3IgcGFnZSBjbGllbnQtc2lkZSBhcyBkYXRhLWZldGNoaW5nIG9wZXJhdGlvbnNcbiAgLy8gd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBkb25lIG9uIHRoZSBzZXJ2ZXIgYW5kIE5FWFRfREFUQSBjb250YWlucyB0aGUgY29ycmVjdFxuICAvLyBkYXRhIGZvciBzdHJhaWdodC1mb3J3YXJkIGh5ZHJhdGlvbiBvZiB0aGUgZXJyb3IgcGFnZVxuICBpZiAoXG4gICAgcmVuZGVyaW5nUHJvcHMuZXJyICYmXG4gICAgLy8gcmVuZGVyaW5nUHJvcHMuQ29tcG9uZW50IG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBhIHRvcC9tb2R1bGUtbGV2ZWwgZXJyb3JcbiAgICAodHlwZW9mIHJlbmRlcmluZ1Byb3BzLkNvbXBvbmVudCA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICFyZW5kZXJpbmdQcm9wcy5pc0h5ZHJhdGVQYXNzKVxuICApIHtcbiAgICBhd2FpdCByZW5kZXJFcnJvcihyZW5kZXJpbmdQcm9wcylcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgZG9SZW5kZXIocmVuZGVyaW5nUHJvcHMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IHJlbmRlckVyciA9IGdldFByb3BlckVycm9yKGVycilcbiAgICAvLyBidWJibGUgdXAgY2FuY2VsYXRpb24gZXJyb3JzXG4gICAgaWYgKChyZW5kZXJFcnIgYXMgRXJyb3IgJiB7IGNhbmNlbGxlZD86IGJvb2xlYW4gfSkuY2FuY2VsbGVkKSB7XG4gICAgICB0aHJvdyByZW5kZXJFcnJcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGlzIGVycm9yIGlzIGRpc3BsYXllZCBpbiB0aGUgb3ZlcmxheSBpbiBkZXZlbG9wbWVudFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IHJlbmRlckVyclxuICAgICAgfSlcbiAgICB9XG4gICAgYXdhaXQgcmVuZGVyRXJyb3IoeyAuLi5yZW5kZXJpbmdQcm9wcywgZXJyOiByZW5kZXJFcnIgfSlcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaHlkcmF0ZShvcHRzPzogeyBiZWZvcmVSZW5kZXI/OiAoKSA9PiBQcm9taXNlPHZvaWQ+IH0pIHtcbiAgbGV0IGluaXRpYWxFcnIgPSBpbml0aWFsRGF0YS5lcnJcblxuICB0cnkge1xuICAgIGNvbnN0IGFwcEVudHJ5cG9pbnQgPSBhd2FpdCBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLndoZW5FbnRyeXBvaW50KCcvX2FwcCcpXG4gICAgaWYgKCdlcnJvcicgaW4gYXBwRW50cnlwb2ludCkge1xuICAgICAgdGhyb3cgYXBwRW50cnlwb2ludC5lcnJvclxuICAgIH1cblxuICAgIGNvbnN0IHsgY29tcG9uZW50OiBhcHAsIGV4cG9ydHM6IG1vZCB9ID0gYXBwRW50cnlwb2ludFxuICAgIENhY2hlZEFwcCA9IGFwcCBhcyBBcHBDb21wb25lbnRcbiAgICBpZiAobW9kICYmIG1vZC5yZXBvcnRXZWJWaXRhbHMpIHtcbiAgICAgIG9uUGVyZkVudHJ5ID0gKHtcbiAgICAgICAgaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlbnRyeVR5cGUsXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIGF0dHJpYnV0aW9uLFxuICAgICAgfTogYW55KTogdm9pZCA9PiB7XG4gICAgICAgIC8vIENvbWJpbmVzIHRpbWVzdGFtcCB3aXRoIHJhbmRvbSBudW1iZXIgZm9yIHVuaXF1ZSBJRFxuICAgICAgICBjb25zdCB1bmlxdWVJRDogc3RyaW5nID0gYCR7RGF0ZS5ub3coKX0tJHtcbiAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoOWUxMiAtIDEpKSArIDFlMTJcbiAgICAgICAgfWBcbiAgICAgICAgbGV0IHBlcmZTdGFydEVudHJ5OiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgICAgICBpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgIHBlcmZTdGFydEVudHJ5ID0gZW50cmllc1swXS5zdGFydFRpbWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdlYlZpdGFsczogTmV4dFdlYlZpdGFsc01ldHJpYyA9IHtcbiAgICAgICAgICBpZDogaWQgfHwgdW5pcXVlSUQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSB8fCBwZXJmU3RhcnRFbnRyeSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUgPT0gbnVsbCA/IGR1cmF0aW9uIDogdmFsdWUsXG4gICAgICAgICAgbGFiZWw6XG4gICAgICAgICAgICBlbnRyeVR5cGUgPT09ICdtYXJrJyB8fCBlbnRyeVR5cGUgPT09ICdtZWFzdXJlJ1xuICAgICAgICAgICAgICA/ICdjdXN0b20nXG4gICAgICAgICAgICAgIDogJ3dlYi12aXRhbCcsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgd2ViVml0YWxzLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb25cbiAgICAgICAgfVxuICAgICAgICBtb2QucmVwb3J0V2ViVml0YWxzKHdlYlZpdGFscylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYWdlRW50cnlwb2ludCA9XG4gICAgICAvLyBUaGUgZGV2IHNlcnZlciBmYWlscyB0byBzZXJ2ZSBzY3JpcHQgYXNzZXRzIHdoZW4gdGhlcmUncyBhIGh5ZHJhdGlvblxuICAgICAgLy8gZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgZW50cnlwb2ludC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGluaXRpYWxEYXRhLmVyclxuICAgICAgICA/IHsgZXJyb3I6IGluaXRpYWxEYXRhLmVyciB9XG4gICAgICAgIDogYXdhaXQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChpbml0aWFsRGF0YS5wYWdlKVxuICAgIGlmICgnZXJyb3InIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICB0aHJvdyBwYWdlRW50cnlwb2ludC5lcnJvclxuICAgIH1cbiAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnRcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID1cbiAgICAgICAgcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJykgYXMgdHlwZW9mIGltcG9ydCgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJylcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENhY2hlZENvbXBvbmVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtpbml0aWFsRGF0YS5wYWdlfVwiYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFRoaXMgY2F0Y2hlcyBlcnJvcnMgbGlrZSB0aHJvd2luZyBpbiB0aGUgdG9wIGxldmVsIG9mIGEgbW9kdWxlXG4gICAgaW5pdGlhbEVyciA9IGdldFByb3BlckVycm9yKGVycm9yKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgY29uc3QgZ2V0U2VydmVyRXJyb3IgPSAoXG4gICAgICByZXF1aXJlKCcuLi9zZXJ2ZXIvZGV2L25vZGUtc3RhY2stZnJhbWVzJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vc2VydmVyL2Rldi9ub2RlLXN0YWNrLWZyYW1lcycpXG4gICAgKS5nZXRTZXJ2ZXJFcnJvclxuICAgIC8vIFNlcnZlci1zaWRlIHJ1bnRpbWUgZXJyb3JzIG5lZWQgdG8gYmUgcmUtdGhyb3duIG9uIHRoZSBjbGllbnQtc2lkZSBzb1xuICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgaWYgKGluaXRpYWxFcnIpIHtcbiAgICAgIGlmIChpbml0aWFsRXJyID09PSBpbml0aWFsRGF0YS5lcnIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbGV0IGVycm9yXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGVycm9yIG9iamVjdC4gV2UgYHRocm93YCBpdCBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuICAgICAgICAgICAgLy8gbm90IG92ZXJyaWRkZW4gd2hlbiB3ZSByZS10aHJvdyBpdCBiZWxvdy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbml0aWFsRXJyIS5tZXNzYWdlKVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gZSBhcyBFcnJvclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyIS5uYW1lXG4gICAgICAgICAgZXJyb3Iuc3RhY2sgPSBpbml0aWFsRXJyIS5zdGFja1xuICAgICAgICAgIGNvbnN0IGVyclNvdXJjZSA9IGluaXRpYWxFcnIuc291cmNlIVxuXG4gICAgICAgICAgLy8gSW4gZGV2ZWxvcG1lbnQsIGVycm9yIHRoZSBuYXZpZ2F0aW9uIEFQSSB1c2FnZSBpbiBydW50aW1lLFxuICAgICAgICAgIC8vIHNpbmNlIGl0J3Mgbm90IGFsbG93ZWQgdG8gYmUgdXNlZCBpbiBwYWdlcyByb3V0ZXIgYXMgaXQgZG9lc24ndCBjb250YWluIGVycm9yIGJvdW5kYXJ5IGxpa2UgYXBwIHJvdXRlci5cbiAgICAgICAgICBpZiAoaXNOZXh0Um91dGVyRXJyb3IoaW5pdGlhbEVycikpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAnTmV4dC5qcyBuYXZpZ2F0aW9uIEFQSSBpcyBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIFBhZ2VzIFJvdXRlci4nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgZ2V0U2VydmVyRXJyb3IoZXJyb3IsIGVyclNvdXJjZSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIC8vIFdlIHJlcGxhY2VkIHRoZSBzZXJ2ZXItc2lkZSBlcnJvciB3aXRoIGEgY2xpZW50LXNpZGUgZXJyb3IsIGFuZCBzaG91bGRcbiAgICAgIC8vIG5vIGxvbmdlciByZXdyaXRlIHRoZSBzdGFjayB0cmFjZSB0byBhIE5vZGUgZXJyb3IuXG4gICAgICBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgaW5pdGlhbEVyclxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSkge1xuICAgIGF3YWl0IHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKGluaXRpYWxEYXRhLmR5bmFtaWNJZHMpXG4gIH1cblxuICByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoaW5pdGlhbERhdGEucGFnZSwgaW5pdGlhbERhdGEucXVlcnksIGFzUGF0aCwge1xuICAgIGluaXRpYWxQcm9wczogaW5pdGlhbERhdGEucHJvcHMsXG4gICAgcGFnZUxvYWRlcixcbiAgICBBcHA6IENhY2hlZEFwcCxcbiAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICB3cmFwQXBwLFxuICAgIGVycjogaW5pdGlhbEVycixcbiAgICBpc0ZhbGxiYWNrOiBCb29sZWFuKGluaXRpYWxEYXRhLmlzRmFsbGJhY2spLFxuICAgIHN1YnNjcmlwdGlvbjogKGluZm8sIEFwcCwgc2Nyb2xsKSA9PlxuICAgICAgcmVuZGVyKFxuICAgICAgICBPYmplY3QuYXNzaWduPFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIE9taXQ8UmVuZGVyUm91dGVJbmZvLCAnQXBwJyB8ICdzY3JvbGwnPixcbiAgICAgICAgICBQaWNrPFJlbmRlclJvdXRlSW5mbywgJ0FwcCcgfCAnc2Nyb2xsJz5cbiAgICAgICAgPih7fSwgaW5mbywge1xuICAgICAgICAgIEFwcCxcbiAgICAgICAgICBzY3JvbGwsXG4gICAgICAgIH0pIGFzIFJlbmRlclJvdXRlSW5mb1xuICAgICAgKSxcbiAgICBsb2NhbGU6IGluaXRpYWxEYXRhLmxvY2FsZSxcbiAgICBsb2NhbGVzOiBpbml0aWFsRGF0YS5sb2NhbGVzLFxuICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgZG9tYWluTG9jYWxlczogaW5pdGlhbERhdGEuZG9tYWluTG9jYWxlcyxcbiAgICBpc1ByZXZpZXc6IGluaXRpYWxEYXRhLmlzUHJldmlldyxcbiAgfSlcblxuICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBhd2FpdCByb3V0ZXIuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2VcblxuICBjb25zdCByZW5kZXJDdHg6IFJlbmRlclJvdXRlSW5mbyA9IHtcbiAgICBBcHA6IENhY2hlZEFwcCxcbiAgICBpbml0aWFsOiB0cnVlLFxuICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgIHByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICBlcnI6IGluaXRpYWxFcnIsXG4gICAgaXNIeWRyYXRlUGFzczogdHJ1ZSxcbiAgfVxuXG4gIGlmIChvcHRzPy5iZWZvcmVSZW5kZXIpIHtcbiAgICBhd2FpdCBvcHRzLmJlZm9yZVJlbmRlcigpXG4gIH1cblxuICByZW5kZXIocmVuZGVyQ3R4KVxufVxuIl0sIm5hbWVzIjpbImVtaXR0ZXIiLCJoeWRyYXRlIiwiaW5pdGlhbGl6ZSIsInJvdXRlciIsInZlcnNpb24iLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1ZFUlNJT04iLCJtaXR0IiwibG9vc2VUb0FycmF5IiwiaW5wdXQiLCJzbGljZSIsImNhbGwiLCJpbml0aWFsRGF0YSIsImRlZmF1bHRMb2NhbGUiLCJ1bmRlZmluZWQiLCJhc1BhdGgiLCJwYWdlTG9hZGVyIiwiYXBwRWxlbWVudCIsImhlYWRNYW5hZ2VyIiwiaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlIiwibGFzdEFwcFByb3BzIiwibGFzdFJlbmRlclJlamVjdCIsImRldkNsaWVudCIsIkNhY2hlZEFwcCIsIm9uUGVyZkVudHJ5IiwiQ2FjaGVkQ29tcG9uZW50IiwiQ29udGFpbmVyIiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudEVyciIsImluZm8iLCJwcm9wcyIsImZuIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJpc1NzciIsImlzRmFsbGJhY2siLCJuZXh0RXhwb3J0IiwiaXNEeW5hbWljUm91dGUiLCJwYXRobmFtZSIsImxvY2F0aW9uIiwic2VhcmNoIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsIl9fTl9TU0ciLCJyZXBsYWNlIiwiU3RyaW5nIiwiYXNzaWduIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwiX2giLCJzaGFsbG93IiwiY2F0Y2giLCJlcnIiLCJjYW5jZWxsZWQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJoYXNoIiwic3Vic3RyaW5nIiwiZWwiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic2V0VGltZW91dCIsInNjcm9sbEludG9WaWV3IiwicmVuZGVyIiwiTk9ERV9FTlYiLCJjaGlsZHJlbiIsIlBhZ2VzRGV2T3ZlcmxheUJyaWRnZSIsInJlcXVpcmUiLCJvcHRzIiwidHJhY2VyIiwib25TcGFuRW5kIiwiZGVmYXVsdCIsIkpTT04iLCJwYXJzZSIsInRleHRDb250ZW50Iiwid2luZG93IiwiX19ORVhUX0RBVEFfXyIsInByZWZpeCIsImFzc2V0UHJlZml4Iiwic2VsZiIsIl9fbmV4dF9zZXRfcHVibGljX3BhdGhfXyIsImdldFVSTCIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsImRldGVjdERvbWFpbkxvY2FsZSIsInBhcnNlUmVsYXRpdmVVcmwiLCJmb3JtYXRVcmwiLCJsb2NhbGVzIiwicGFyc2VkQXMiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJsb2NhbGUiLCJkZXRlY3RlZERvbWFpbiIsIl9fTkVYVF9JMThOX0RPTUFJTlMiLCJob3N0bmFtZSIsInNjcmlwdExvYWRlciIsImluaXRTY3JpcHRMb2FkZXIiLCJQYWdlTG9hZGVyIiwiYnVpbGRJZCIsInJlZ2lzdGVyIiwiciIsImYiLCJyb3V0ZUxvYWRlciIsIm9uRW50cnlwb2ludCIsIl9fTkVYVF9QIiwibWFwIiwicCIsInB1c2giLCJpbml0SGVhZE1hbmFnZXIiLCJnZXRJc1NzciIsInJlbmRlckFwcCIsIkFwcCIsImFwcFByb3BzIiwiQXBwQ29udGFpbmVyIiwiYWRhcHRlZEZvckFwcFJvdXRlciIsInVzZU1lbW8iLCJhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlIiwiZXJyb3IiLCJyZW5kZXJFcnJvciIsImNvbnNvbGUiLCJBcHBSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJhZGFwdEZvclNlYXJjaFBhcmFtcyIsIlBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlciIsImlzQXV0b0V4cG9ydCIsImF1dG9FeHBvcnQiLCJQYXRoUGFyYW1zQ29udGV4dCIsImFkYXB0Rm9yUGF0aFBhcmFtcyIsIlJvdXRlckNvbnRleHQiLCJtYWtlUHVibGljUm91dGVySW5zdGFuY2UiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJfX05FWFRfSU1BR0VfT1BUUyIsIndyYXBBcHAiLCJ3cmFwcGVkQXBwUHJvcHMiLCJyZW5kZXJFcnJvclByb3BzIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJkb1JlbmRlciIsInN0eWxlU2hlZXRzIiwibG9hZFBhZ2UiLCJ0aGVuIiwicGFnZSIsIkVycm9yQ29tcG9uZW50IiwiZXJyb3JNb2R1bGUiLCJhcHBNb2R1bGUiLCJtIiwiQXBwVHJlZSIsImFwcEN0eCIsImN0eCIsIlByb21pc2UiLCJyZXNvbHZlIiwibG9hZEdldEluaXRpYWxQcm9wcyIsImluaXRQcm9wcyIsIkhlYWQiLCJjYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsInBlcmZvcm1hbmNlTWFya3MiLCJuYXZpZ2F0aW9uU3RhcnQiLCJiZWZvcmVSZW5kZXIiLCJhZnRlclJlbmRlciIsImFmdGVySHlkcmF0ZSIsInJvdXRlQ2hhbmdlIiwicGVyZm9ybWFuY2VNZWFzdXJlcyIsImh5ZHJhdGlvbiIsImJlZm9yZUh5ZHJhdGlvbiIsInJvdXRlQ2hhbmdlVG9SZW5kZXIiLCJyZWFjdFJvb3QiLCJzaG91bGRIeWRyYXRlIiwiY2xlYXJNYXJrcyIsImZvckVhY2giLCJtYXJrIiwicGVyZm9ybWFuY2UiLCJtYXJrSHlkcmF0ZUNvbXBsZXRlIiwiU1QiLCJoYXNCZWZvcmVSZW5kZXJNYXJrIiwiZ2V0RW50cmllc0J5TmFtZSIsImxlbmd0aCIsImJlZm9yZUh5ZHJhdGlvbk1lYXN1cmUiLCJtZWFzdXJlIiwiaHlkcmF0aW9uTWVhc3VyZSIsInN0YXJ0U3BhbiIsInN0YXJ0VGltZSIsInRpbWVPcmlnaW4iLCJhdHRyaWJ1dGVzIiwiZW5kIiwiZHVyYXRpb24iLCJtYXJrUmVuZGVyQ29tcGxldGUiLCJuYXZTdGFydEVudHJpZXMiLCJuYW1lIiwiY2xlYXJNZWFzdXJlcyIsInJlbmRlclJlYWN0RWxlbWVudCIsImRvbUVsIiwicmVhY3RFbCIsIlJlYWN0RE9NIiwiaHlkcmF0ZVJvb3QiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJzdGFydFRyYW5zaXRpb24iLCJSb290IiwiY2FsbGJhY2tzIiwiX19ORVhUX1RFU1RfTU9ERSIsInVzZUVmZmVjdCIsIl9fTkVYVF9IWURSQVRFRCIsIl9fTkVYVF9IWURSQVRFRF9BVCIsIm5vdyIsIl9fTkVYVF9IWURSQVRFRF9DQiIsImNhbmNlbGVkIiwicmVzb2x2ZVByb21pc2UiLCJyZW5kZXJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJvblN0YXJ0IiwiY3VycmVudFN0eWxlVGFncyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjdXJyZW50SHJlZnMiLCJTZXQiLCJ0YWciLCJnZXRBdHRyaWJ1dGUiLCJub3NjcmlwdCIsInF1ZXJ5U2VsZWN0b3IiLCJub25jZSIsImhyZWYiLCJ0ZXh0IiwiaGFzIiwic3R5bGVUYWciLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJvbkhlYWRDb21taXQiLCJUVVJCT1BBQ0siLCJkZXNpcmVkSHJlZnMiLCJzIiwiaWR4IiwicmVtb3ZlQXR0cmlidXRlIiwicmVmZXJlbmNlTm9kZSIsInRhcmdldFRhZyIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsInJlbW92ZUNoaWxkIiwic2Nyb2xsIiwieCIsInkiLCJkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uIiwic2Nyb2xsVG8iLCJvblJvb3RDb21taXQiLCJlbGVtIiwiUG9ydGFsIiwidHlwZSIsIlJvdXRlQW5ub3VuY2VyIiwiX19ORVhUX1NUUklDVF9NT0RFIiwiU3RyaWN0TW9kZSIsInJlbmRlcmluZ1Byb3BzIiwiaXNIeWRyYXRlUGFzcyIsInJlbmRlckVyciIsImdldFByb3BlckVycm9yIiwiaW5pdGlhbEVyciIsImFwcEVudHJ5cG9pbnQiLCJ3aGVuRW50cnlwb2ludCIsImNvbXBvbmVudCIsImFwcCIsImV4cG9ydHMiLCJtb2QiLCJyZXBvcnRXZWJWaXRhbHMiLCJpZCIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJhdHRyaWJ1dGlvbiIsInVuaXF1ZUlEIiwiRGF0ZSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInBlcmZTdGFydEVudHJ5Iiwid2ViVml0YWxzIiwibGFiZWwiLCJwYWdlRW50cnlwb2ludCIsImlzVmFsaWRFbGVtZW50VHlwZSIsImdldFNlcnZlckVycm9yIiwibWVzc2FnZSIsImUiLCJzdGFjayIsImVyclNvdXJjZSIsInNvdXJjZSIsImlzTmV4dFJvdXRlckVycm9yIiwiX19ORVhUX1BSRUxPQURSRUFEWSIsImR5bmFtaWNJZHMiLCJjcmVhdGVSb3V0ZXIiLCJpbml0aWFsUHJvcHMiLCJCb29sZWFuIiwic3Vic2NyaXB0aW9uIiwiT2JqZWN0IiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwicmVuZGVyQ3R4IiwiaW5pdGlhbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createKey: function() {\n        return createKey;\n    },\n    default: function() {\n        return Router;\n    },\n    matchesMiddleware: function() {\n        return matchesMiddleware;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"(pages-dir-browser)/./node_modules/next/dist/client/route-loader.js\");\nconst _script = __webpack_require__(/*! ../../../client/script */ \"(pages-dir-browser)/./node_modules/next/dist/client/script.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"(pages-dir-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nconst _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _utils = __webpack_require__(/*! ../utils */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nconst _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nconst _formaturl = __webpack_require__(/*! ./utils/format-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/detect-domain-locale.js\");\nconst _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/remove-locale.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"(pages-dir-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"(pages-dir-browser)/./node_modules/next/dist/lib/is-api-route.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nconst _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _isbot = __webpack_require__(/*! ./utils/is-bot */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _omit = __webpack_require__(/*! ./utils/omit */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nconst _disablesmoothscroll = __webpack_require__(/*! ./utils/disable-smooth-scroll */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js\");\nconst _constants = __webpack_require__(/*! ../../../lib/constants */ \"(pages-dir-browser)/./node_modules/next/dist/lib/constants.js\");\nlet resolveRewrites;\nif (false) {}\nfunction buildCancellationError() {\n    return Object.assign(Object.defineProperty(new Error('Route Cancelled'), \"__NEXT_ERROR_CODE\", {\n        value: \"E315\",\n        enumerable: false,\n        configurable: true\n    }), {\n        cancelled: true\n    });\n}\nasync function matchesMiddleware(options) {\n    const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n    const origin = (0, _utils.getLocationOrigin)();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n    let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n    const matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);\n    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith('/') || false) {\n            const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then(([pages, { __rewrites: rewrites }])=>{\n                let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) {} else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: 'rewrite',\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsepath.parsePath)(source);\n        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                nextConfig,\n                parseData: true\n            }),\n            defaultLocale: options.router.defaultLocale,\n            buildId: ''\n        });\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: `${pathname}${src.query}${src.hash}`\n        });\n    }\n    const redirectTarget = response.headers.get('x-nextjs-redirect');\n    if (redirectTarget) {\n        if (redirectTarget.startsWith('/')) {\n            const src = (0, _parsepath.parsePath)(redirectTarget);\n            const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n                ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                    nextConfig,\n                    parseData: true\n                }),\n                defaultLocale: options.router.defaultLocale,\n                buildId: ''\n            });\n            return Promise.resolve({\n                type: 'redirect-internal',\n                newAs: `${pathname}${src.query}${src.hash}`,\n                newUrl: `${pathname}${src.query}${src.hash}`\n            });\n        }\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: 'next'\n    });\n}\nasync function withMiddlewareEffects(options) {\n    const matches = await matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n        return null;\n    }\n    const data = await options.fetchData();\n    const effect = await getMiddlewareData(data.dataHref, data.response, options);\n    return {\n        dataHref: data.dataHref,\n        json: data.json,\n        response: data.response,\n        text: data.text,\n        cacheKey: data.cacheKey,\n        effect\n    };\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wont send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin',\n        method: options.method || 'GET',\n        headers: Object.assign({}, options.headers, {\n            'x-nextjs-data': '1'\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData({ dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache }) {\n    const { href: cacheKey } = new URL(dataHref, window.location.href);\n    const getData = (params)=>fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: 'prefetch'\n            } : {}, isPrefetch && hasMiddleware ? {\n                'x-middleware-prefetch': '1'\n            } : {},  false ? 0 : {}),\n            method: params?.method ?? 'GET'\n        }).then((response)=>{\n            if (response.ok && params?.method === 'HEAD') {\n                return {\n                    dataHref,\n                    response,\n                    text: '',\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        if (tryToParseAsJSON(text)?.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = Object.defineProperty(new Error(`Failed to load static props`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E124\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || \"development\" !== 'production' || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === 'Failed to fetch' || // firefox\n            err.message === 'NetworkError when attempting to fetch resource.' || // safari\n            err.message === 'Load failed') {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {\n                // only update cache if not marked as no-cache\n                inflightCache[cacheKey] = Promise.resolve(data);\n            }\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: 'HEAD'\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation({ url, router }) {\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw Object.defineProperty(new Error(`Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E282\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = ({ route, router })=>{\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = Object.defineProperty(new Error(`Abort fetching component for route: \"${route}\"`), \"__NEXT_ERROR_CODE\", {\n                value: \"E483\",\n                enumerable: false,\n                configurable: true\n            });\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    static{\n        this.events = (0, _mitt.default)();\n    }\n    constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname, query } = this;\n                this.changeState('replaceState', (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(pathname),\n                    query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url, as, options, key } = state;\n            if (false) {}\n            this._key = key;\n            const { pathname } = (0, _parserelativeurl.parseRelativeUrl)(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== '/_error') {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || '';\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    // if middleware matches we leave resolving to the change function\n                    // as the server needs to resolve for correct priority\n                    ;\n                    options._shouldResolveHref = as !== pathname;\n                    this.changeState('replaceState', matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {}) {\n        if (false) {}\n        ;\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {}) {\n        ;\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    async _bfl(as, resolvedAs, locale, skipNavigate) {\n        if (true) {\n            if (!this._bfl_s && !this._bfl_d) {\n                const { BloomFilter } = __webpack_require__(/*! ../../lib/bloom-filter */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/bloom-filter.js\");\n                let staticFilterData;\n                let dynamicFilterData;\n                try {\n                    ;\n                    ({ __routerFilterStatic: staticFilterData, __routerFilterDynamic: dynamicFilterData } = await (0, _routeloader.getClientBuildManifest)());\n                } catch (err) {\n                    // failed to load build manifest hard navigate\n                    // to be safe\n                    console.error(err);\n                    if (skipNavigate) {\n                        return true;\n                    }\n                    handleHardNavigation({\n                        url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routerFilterSValue = {\"numItems\":11,\"errorRate\":0.0001,\"numBits\":211,\"numHashes\":14,\"bitArray\":[1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,1,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1]};\n                if (!staticFilterData && routerFilterSValue) {\n                    staticFilterData = routerFilterSValue ? routerFilterSValue : undefined;\n                }\n                const routerFilterDValue = {\"numItems\":1,\"errorRate\":0.0001,\"numBits\":20,\"numHashes\":14,\"bitArray\":[1,1,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,1]};\n                if (!dynamicFilterData && routerFilterDValue) {\n                    dynamicFilterData = routerFilterDValue ? routerFilterDValue : undefined;\n                }\n                if (staticFilterData?.numHashes) {\n                    this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                    this._bfl_s.import(staticFilterData);\n                }\n                if (dynamicFilterData?.numHashes) {\n                    this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                    this._bfl_d.import(dynamicFilterData);\n                }\n            }\n            let matchesBflStatic = false;\n            let matchesBflDynamic = false;\n            const pathsToCheck = [\n                {\n                    as\n                },\n                {\n                    as: resolvedAs\n                }\n            ];\n            for (const { as: curAs, allowMatchCurrent } of pathsToCheck){\n                if (curAs) {\n                    const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, 'http://n').pathname);\n                    const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n                    if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, 'http://n').pathname)) {\n                        matchesBflStatic = matchesBflStatic || !!this._bfl_s?.contains(asNoSlash) || !!this._bfl_s?.contains(asNoSlashLocale);\n                        for (const normalizedAS of [\n                            asNoSlash,\n                            asNoSlashLocale\n                        ]){\n                            // if any sub-path of as matches a dynamic filter path\n                            // it should be hard navigated\n                            const curAsParts = normalizedAS.split('/');\n                            for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                const currentPart = curAsParts.slice(0, i).join('/');\n                                if (currentPart && this._bfl_d?.contains(currentPart)) {\n                                    matchesBflDynamic = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // if the client router filter is matched then we trigger\n                        // a hard navigation\n                        if (matchesBflStatic || matchesBflDynamic) {\n                            if (skipNavigate) {\n                                return true;\n                            }\n                            handleHardNavigation({\n                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                                router: this\n                            });\n                            return new Promise(()=>{});\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    async change(method, url, as, options, forcedScroll) {\n        if (!(0, _islocalurl.isLocalURL)(url)) {\n            handleHardNavigation({\n                url,\n                router: this\n            });\n            return false;\n        }\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        const isQueryUpdating = options._h === 1;\n        if (!isQueryUpdating && !options.shallow) {\n            await this._bfl(as, undefined, options.locale);\n        }\n        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        // or a navigation has occurred\n        const readyStateChange = this.isReady !== true;\n        this.isReady = true;\n        const isSsr = this.isSsr;\n        if (!isQueryUpdating) {\n            this.isSsr = false;\n        }\n        // if a route transition is already in progress before\n        // the query updating is triggered ignore query updating\n        if (isQueryUpdating && this.clc) {\n            return false;\n        }\n        const prevLocale = nextState.locale;\n        if (false) {}\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark('routeChange');\n        }\n        const { shallow = false, scroll = true } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute && this.clc) {\n            if (!isSsr) {\n                Router.events.emit('routeChangeError', buildCancellationError(), this._inFlightRoute, routeProps);\n            }\n            this.clc();\n            this.clc = null;\n        }\n        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        const localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit('hashChangeStart', as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            try {\n                await this.set(nextState, this.components[nextState.route], null);\n            } catch (err) {\n                if ((0, _iserror.default)(err) && err.cancelled) {\n                    Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                }\n                throw err;\n            }\n            Router.events.emit('hashChangeComplete', as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        let { pathname, query } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            ;\n            [pages, { __rewrites: rewrites }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)(),\n                this.pageLoader.getMiddleware()\n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = 'replaceState';\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const parsedAsPathname = as.startsWith('/') && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n        // if we detected the path as app route during prefetching\n        // trigger hard navigation\n        if (this.components[pathname]?.__appRouter) {\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return new Promise(()=>{});\n        }\n        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n        // we don't attempt resolve asPath when we need to execute\n        // middleware as the resolving will occur server-side\n        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({\n            asPath: as,\n            locale: nextState.locale,\n            router: this\n        });\n        if (isQueryUpdating && isMiddlewareMatch) {\n            shouldResolveHref = false;\n        }\n        if (shouldResolveHref && pathname !== '/_error') {\n            ;\n            options._shouldResolveHref = true;\n            if (false) {} else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            }\n        }\n        if (!(0, _islocalurl.isLocalURL)(as)) {\n            if (true) {\n                throw Object.defineProperty(new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E380\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        let routeMatch = false;\n        if ((0, _isdynamic.isDynamicRoute)(route)) {\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeregex.getRouteRegex)(route);\n            routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                if (missingParams.length > 0 && !isMiddlewareMatch) {\n                    if (true) {\n                        console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                    }\n                    throw Object.defineProperty(new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E344\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        if (!isQueryUpdating) {\n            Router.events.emit('routeChangeStart', as, routeProps);\n        }\n        const isErrorRoute = this.pathname === '/404' || this.pathname === '/_error';\n        try {\n            let routeInfo = await this.getRouteInfo({\n                route,\n                pathname,\n                query,\n                as,\n                resolvedAs,\n                routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite\n            });\n            if (!isQueryUpdating && !options.shallow) {\n                await this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n            }\n            if ('route' in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n                if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                }\n                const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach((key)=>{\n                        if (routeMatch && query[key] === routeMatch[key]) {\n                            delete query[key];\n                        }\n                    });\n                }\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    let rewriteAs = prefixedAs;\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                        rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n                    if (false) {}\n                    const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                    if (curRouteMatch) {\n                        Object.assign(query, curRouteMatch);\n                    }\n                }\n            }\n            // If the routeInfo brings a redirect we simply apply it.\n            if ('type' in routeInfo) {\n                if (routeInfo.type === 'redirect-internal') {\n                    return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                } else {\n                    handleHardNavigation({\n                        url: routeInfo.destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n            }\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script.handleClientScriptLoad)(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                    // Use the destination from redirect without adding locale\n                    options.locale = false;\n                    const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    handleHardNavigation({\n                        url: destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                // handle SSG data 404\n                if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent('/404');\n                        notFoundRoute = '/404';\n                    } catch (_) {\n                        notFoundRoute = '/_error';\n                    }\n                    routeInfo = await this.getRouteInfo({\n                        route: notFoundRoute,\n                        pathname: notFoundRoute,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isNotFound: true\n                    });\n                    if ('type' in routeInfo) {\n                        throw Object.defineProperty(new Error(`Unexpected middleware effect on /404`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E158\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                }\n            }\n            if (isQueryUpdating && this.pathname === '/_error' && self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 && routeInfo.props?.pageProps) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n            }\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === (routeInfo.route ?? route);\n            const shouldScroll = options.scroll ?? (!isQueryUpdating && !isValidShallowRoute);\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            const upcomingScrollState = forcedScroll ?? resetScroll;\n            // the new state that the router gonna set\n            const upcomingRouterState = {\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            };\n            // When the page being rendered is the 404 page, we should only update the\n            // query parameters. Route changes here might add the basePath when it\n            // wasn't originally present. This is also why this block is before the\n            // below `changeState` call which updates the browser's history (changing\n            // the URL).\n            if (isQueryUpdating && isErrorRoute) {\n                routeInfo = await this.getRouteInfo({\n                    route: this.pathname,\n                    pathname: this.pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps: {\n                        shallow: false\n                    },\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n                if ('type' in routeInfo) {\n                    throw Object.defineProperty(new Error(`Unexpected middleware effect on ${this.pathname}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E225\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (this.pathname === '/_error' && self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 && routeInfo.props?.pageProps) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.cancelled) {\n                        Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                return true;\n            }\n            Router.events.emit('beforeHistoryChange', as, routeProps);\n            this.changeState(method, url, as, options);\n            // for query updates we can skip it if the state is unchanged and we don't\n            // need to scroll\n            // https://github.com/vercel/next.js/issues/37139\n            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n            if (!canSkipUpdating) {\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (e) {\n                    if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                    else throw e;\n                }\n                if (routeInfo.error) {\n                    if (!isQueryUpdating) {\n                        Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);\n                    }\n                    throw routeInfo.error;\n                }\n                if (false) {}\n                if (!isQueryUpdating) {\n                    Router.events.emit('routeChangeComplete', as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                const hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                    this.scrollToHash(as);\n                }\n            }\n            return true;\n        } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n                return false;\n            }\n            throw err;\n        }\n    }\n    changeState(method, url, as, options = {}) {\n        if (true) {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== 'pushState' ? this._key : createKey()\n            }, // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n            Router.events.emit('routeChangeError', err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        console.error(err);\n        try {\n            let props;\n            const { page: Component, styleSheets } = await this.fetchComponent('/_error');\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error('Error in error page `getInitialProps`: ', gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : Object.defineProperty(new Error(routeInfoErr + ''), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            }), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo({ route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound }) {\n        /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n        try {\n            let existingInfo = this.components[route];\n            if (routeProps.shallow && existingInfo && this.route === route) {\n                return existingInfo;\n            }\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: this\n            });\n            if (hasMiddleware) {\n                existingInfo = undefined;\n            }\n            let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && \"development\" !== 'development' ? 0 : undefined;\n            const isBackground = isQueryUpdating;\n            const fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                        pathname,\n                        query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? '/404' : resolvedAs,\n                    locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache,\n                isBackground\n            };\n            let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n                fetchData: ()=>fetchNextData(fetchNextDataParams),\n                asPath: isNotFound ? '/404' : resolvedAs,\n                locale: locale,\n                router: this\n            }).catch((err)=>{\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                    return null;\n                }\n                throw err;\n            });\n            // when rendering error routes we don't apply middleware\n            // effects\n            if (data && (pathname === '/_error' || pathname === '/404')) {\n                data.effect = undefined;\n            }\n            if (isQueryUpdating) {\n                if (!data) {\n                    data = {\n                        json: self.__NEXT_DATA__.props\n                    };\n                } else {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n            }\n            handleCancelled();\n            if (data?.effect?.type === 'redirect-internal' || data?.effect?.type === 'redirect-external') {\n                return data.effect;\n            }\n            if (data?.effect?.type === 'rewrite') {\n                const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                const pages = await this.pageLoader.getPageList();\n                // during query updating the page must match although during\n                // client-transition a redirect that doesn't match a page\n                // can be returned and this should trigger a hard navigation\n                // which is valid for incremental migration\n                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                    route = resolvedRoute;\n                    pathname = data.effect.resolvedHref;\n                    query = {\n                        ...query,\n                        ...data.effect.parsedAs.query\n                    };\n                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = this.components[route];\n                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return {\n                            ...existingInfo,\n                            route\n                        };\n                    }\n                }\n            }\n            if ((0, _isapiroute.isAPIRoute)(route)) {\n                handleHardNavigation({\n                    url: as,\n                    router: this\n                });\n                return new Promise(()=>{});\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                }));\n            if (true) {\n                const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/react-is/index.js\");\n                if (!isValidElementType(routeInfo.Component)) {\n                    throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"${pathname}\"`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E286\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            const wasBailedPrefetch = data?.response?.headers.get('x-middleware-skip');\n            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n            // For non-SSG prefetches that bailed before sending data\n            // we clear the cache to fetch full response\n            if (wasBailedPrefetch && data?.dataHref) {\n                delete this.sdc[data.dataHref];\n            }\n            const { props, cacheKey } = await this._getData(async ()=>{\n                if (shouldFetchData) {\n                    if (data?.json && !wasBailedPrefetch) {\n                        return {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                        };\n                    }\n                    const dataHref = data?.dataHref ? data.dataHref : this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname,\n                            query\n                        }),\n                        asPath: resolvedAs,\n                        locale\n                    });\n                    const fetched = await fetchNextData({\n                        dataHref,\n                        isServerRender: this.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : this.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache\n                    });\n                    return {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                    };\n                }\n                return {\n                    headers: {},\n                    props: await this.getInitialProps(routeInfo.Component, {\n                        pathname,\n                        query,\n                        asPath: as,\n                        locale,\n                        locales: this.locales,\n                        defaultLocale: this.defaultLocale\n                    })\n                };\n            });\n            // Only bust the data cache for SSP routes although\n            // middleware can skip cache per request with\n            // x-middleware-cache: no-cache as well\n            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n            }\n            // we kick off a HEAD request in the background\n            // when a non-prefetch request is made to signal revalidation\n            if (!this.isPreview && routeInfo.__N_SSG && \"development\" !== 'development' && 0) {}\n            props.pageProps = Object.assign({}, props.pageProps);\n            routeInfo.props = props;\n            routeInfo.route = route;\n            routeInfo.query = query;\n            routeInfo.resolvedAs = resolvedAs;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#', 2);\n        const [newUrlNoHash, newHash] = as.split('#', 2);\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#', 2);\n        (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{\n            // Scroll to top if the hash is just `#` with no value or `#top`\n            // To mirror browsers\n            if (hash === '' || hash === 'top') {\n                window.scrollTo(0, 0);\n                return;\n            }\n            // Decode hash to make non-latin anchor works.\n            const rawHash = decodeURIComponent(hash);\n            // First we check if the element by id is found\n            const idEl = document.getElementById(rawHash);\n            if (idEl) {\n                idEl.scrollIntoView();\n                return;\n            }\n            // If there's no element with the id, we check the `name` property\n            // To mirror browsers\n            const nameEl = document.getElementsByName(rawHash)[0];\n            if (nameEl) {\n                nameEl.scrollIntoView();\n            }\n        }, {\n            onlyHashChange: this.onlyAHashChange(as)\n        });\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath = url, options = {}) {\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (true) {\n            return;\n        }\n        if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n            // No prefetches for bots that render the link since they are typically navigating\n            // links via the equivalent of a hard navigation and hence never utilize these\n            // prefetches.\n            return;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        const urlPathname = parsed.pathname;\n        let { pathname, query } = parsed;\n        const originalPathname = pathname;\n        if (false) {}\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : this.locale;\n        const isMiddlewareMatch = await matchesMiddleware({\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        if (false) {}\n        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n            pathname = parsed.pathname;\n            parsed.pathname = pathname;\n            Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n            if (!isMiddlewareMatch) {\n                url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n        }\n        const data =  false ? 0 : await withMiddlewareEffects({\n            fetchData: ()=>fetchNextData({\n                    dataHref: this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname: originalPathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true\n                }),\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if (data?.effect.type === 'rewrite') {\n            parsed.pathname = data.effect.resolvedHref;\n            pathname = data.effect.resolvedHref;\n            query = {\n                ...query,\n                ...data.effect.parsedAs.query\n            };\n            resolvedAs = data.effect.parsedAs.pathname;\n            url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n        /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if (data?.effect.type === 'redirect-external') {\n            return;\n        }\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n            this.components[urlPathname] = {\n                __appRouter: true\n            };\n        }\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData({\n                    dataHref: data?.json ? data?.dataHref : this.pageLoader.getDataHref({\n                        href: url,\n                        asPath: resolvedAs,\n                        locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                }).then(()=>false).catch(()=>false) : false;\n            }),\n            this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)\n        ]);\n    }\n    async fetchComponent(route) {\n        const handleCancelled = getCancelledHandler({\n            route,\n            router: this\n        });\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = Object.defineProperty(new Error('Loading initial props cancelled'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E405\",\n                    enumerable: false,\n                    configurable: true\n                });\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils.loadGetInitialProps)(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n} //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTRtQmdCQSxTQUFTO2VBQVRBOztJQWlEaEIsT0FpNERDO2VBajREb0JDOztJQTdqQkNDLGlCQUFpQjtlQUFqQkE7Ozs7O2lEQXZGYzt5Q0FLN0I7b0NBQ2dDOytFQUNDO2lEQUNKO2lEQUNBOzJFQUNuQjttQ0FDa0Q7dUNBQ3BDOzhDQUNFOzBDQUNEO3dDQUNGO3VDQUNPO2dEQUNGO3VDQUNUO3VDQUNBOzBDQUNHOzRDQUNFO3lDQUNIO3lDQUNBO3lDQUNBO3dDQUNEO2lEQUNTO29EQUNHOzJDQUNIO3dDQUNUO21DQUNMO2tDQUNEOzJDQUNTO2lEQUMyQjt1Q0FFckI7QUFFcEMsSUFBSUM7QUFDSixJQUFJQyxLQUErQixFQUFFLEVBSXBDO0FBZ0NELFNBQVNLO0lBQ1AsT0FBT0MsT0FBT0MsTUFBTSxDQUFDLHFCQUE0QixDQUE1QixJQUFJQyxNQUFNLG9CQUFWO2VBQUE7b0JBQUE7c0JBQUE7SUFBMkIsSUFBRztRQUNqREMsV0FBVztJQUNiO0FBQ0Y7QUFTTyxlQUFlWCxrQkFDcEJZLE9BQWtDO0lBRWxDLE1BQU1DLFdBQVcsTUFBTUMsUUFBUUMsT0FBTyxDQUNwQ0gsUUFBUUksTUFBTSxDQUFDQyxVQUFVLENBQUNDLGFBQWE7SUFFekMsSUFBSSxDQUFDTCxVQUFVLE9BQU87SUFFdEIsTUFBTSxFQUFFTSxVQUFVQyxVQUFVLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsV0FBQUEsU0FBQUEsRUFBVVQsUUFBUVUsTUFBTTtJQUN6RCw2RkFBNkY7SUFDN0YsTUFBTUMsWUFBWUMsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWUosY0FDMUJLLENBQUFBLEdBQUFBLGdCQUFBQSxjQUFBQSxFQUFlTCxjQUNmQTtJQUNKLE1BQU1NLDBCQUEwQkMsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFD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Q0FBQ2hHLEtBQUs7SUFDekI7SUFFQSxJQUFJeEUsU0FBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUN3SyxLQUFLLENBQUN4SyxNQUFNO0lBQzFCO0lBRUEsSUFBSU8sU0FBNkI7UUFDL0IsT0FBTyxJQUFJLENBQUNpSyxLQUFLLENBQUNqSyxNQUFNO0lBQzFCO0lBRUEsSUFBSXdKLGFBQXNCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDUyxLQUFLLENBQUNULFVBQVU7SUFDOUI7SUFFQSxJQUFJRSxZQUFxQjtRQUN2QixPQUFPLElBQUksQ0FBQ08sS0FBSyxDQUFDUCxTQUFTO0lBQzdCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL3NyYy9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IERvbWFpbkxvY2FsZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgdHlwZSB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB0eXBlIHsgUm91dGVyRXZlbnQgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcm91dGVyJ1xuaW1wb3J0IHR5cGUgeyBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQgdHlwZSB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB0eXBlIFBhZ2VMb2FkZXIgZnJvbSAnLi4vLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHR5cGUgeyBBcHBDb250ZXh0VHlwZSwgTmV4dFBhZ2VDb250ZXh0LCBORVhUX0RBVEEgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IHJlbW92ZVRyYWlsaW5nU2xhc2ggfSBmcm9tICcuL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaCdcbmltcG9ydCB7XG4gIGdldENsaWVudEJ1aWxkTWFuaWZlc3QsXG4gIGlzQXNzZXRFcnJvcixcbiAgbWFya0Fzc2V0RXJyb3IsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXInXG5pbXBvcnQgeyBoYW5kbGVDbGllbnRTY3JpcHRMb2FkIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3NjcmlwdCdcbmltcG9ydCBpc0Vycm9yLCB7IGdldFByb3BlckVycm9yIH0gZnJvbSAnLi4vLi4vLi4vbGliL2lzLWVycm9yJ1xuaW1wb3J0IHsgZGVub3JtYWxpemVQYWdlUGF0aCB9IGZyb20gJy4uL3BhZ2UtcGF0aC9kZW5vcm1hbGl6ZS1wYWdlLXBhdGgnXG5pbXBvcnQgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gZnJvbSAnLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnXG5pbXBvcnQgbWl0dCBmcm9tICcuLi9taXR0J1xuaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4sIGdldFVSTCwgbG9hZEdldEluaXRpYWxQcm9wcywgU1QgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHsgZ2V0Um91dGVNYXRjaGVyIH0gZnJvbSAnLi91dGlscy9yb3V0ZS1tYXRjaGVyJ1xuaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vdXRpbHMvcm91dGUtcmVnZXgnXG5pbXBvcnQgeyBmb3JtYXRXaXRoVmFsaWRhdGlvbiB9IGZyb20gJy4vdXRpbHMvZm9ybWF0LXVybCdcbmltcG9ydCB7IGRldGVjdERvbWFpbkxvY2FsZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZSdcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcGF0aCdcbmltcG9ydCB7IGFkZExvY2FsZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlJ1xuaW1wb3J0IHsgcmVtb3ZlTG9jYWxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGUnXG5pbXBvcnQgeyByZW1vdmVCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGgnXG5pbXBvcnQgeyByZXNvbHZlSHJlZiB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yZXNvbHZlLWhyZWYnXG5pbXBvcnQgeyBpc0FQSVJvdXRlIH0gZnJvbSAnLi4vLi4vLi4vbGliL2lzLWFwaS1yb3V0ZSdcbmltcG9ydCB7IGdldE5leHRQYXRobmFtZUluZm8gfSBmcm9tICcuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm8nXG5pbXBvcnQgeyBmb3JtYXROZXh0UGF0aG5hbWVJbmZvIH0gZnJvbSAnLi91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvJ1xuaW1wb3J0IHsgY29tcGFyZVJvdXRlclN0YXRlcyB9IGZyb20gJy4vdXRpbHMvY29tcGFyZS1zdGF0ZXMnXG5pbXBvcnQgeyBpc0xvY2FsVVJMIH0gZnJvbSAnLi91dGlscy9pcy1sb2NhbC11cmwnXG5pbXBvcnQgeyBpc0JvdCB9IGZyb20gJy4vdXRpbHMvaXMtYm90J1xuaW1wb3J0IHsgb21pdCB9IGZyb20gJy4vdXRpbHMvb21pdCdcbmltcG9ydCB7IGludGVycG9sYXRlQXMgfSBmcm9tICcuL3V0aWxzL2ludGVycG9sYXRlLWFzJ1xuaW1wb3J0IHsgZGlzYWJsZVNtb290aFNjcm9sbER1cmluZ1JvdXRlVHJhbnNpdGlvbiB9IGZyb20gJy4vdXRpbHMvZGlzYWJsZS1zbW9vdGgtc2Nyb2xsJ1xuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5pbXBvcnQgeyBNQVRDSEVEX1BBVEhfSEVBREVSIH0gZnJvbSAnLi4vLi4vLi4vbGliL2NvbnN0YW50cydcblxubGV0IHJlc29sdmVSZXdyaXRlczogdHlwZW9mIGltcG9ydCgnLi91dGlscy9yZXNvbHZlLXJld3JpdGVzJykuZGVmYXVsdFxuaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgcmVzb2x2ZVJld3JpdGVzID0gKFxuICAgIHJlcXVpcmUoJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcycpIGFzIHR5cGVvZiBpbXBvcnQoJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcycpXG4gICkuZGVmYXVsdFxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIC8qIHByb2QgKi9cbiAgICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgfVxufVxuXG5pbnRlcmZhY2UgUm91dGVQcm9wZXJ0aWVzIHtcbiAgc2hhbGxvdzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICBzaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuICBzY3JvbGw/OiBib29sZWFuXG4gIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZT86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE5leHRIaXN0b3J5U3RhdGUge1xuICB1cmw6IHN0cmluZ1xuICBhczogc3RyaW5nXG4gIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zXG59XG5cbmV4cG9ydCB0eXBlIEhpc3RvcnlTdGF0ZSA9XG4gIHwgbnVsbFxuICB8IHsgX19OQTogdHJ1ZTsgX19OPzogZmFsc2UgfVxuICB8IHsgX19OOiBmYWxzZTsgX19OQT86IGZhbHNlIH1cbiAgfCAoeyBfX05BPzogZmFsc2U7IF9fTjogdHJ1ZTsga2V5OiBzdHJpbmcgfSAmIE5leHRIaXN0b3J5U3RhdGUpXG5cbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICBjYW5jZWxsZWQ6IHRydWUsXG4gIH0pXG59XG5cbmludGVyZmFjZSBNaWRkbGV3YXJlRWZmZWN0UGFyYW1zPFQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQ+IHtcbiAgZmV0Y2hEYXRhPzogKCkgPT4gUHJvbWlzZTxUPlxuICBsb2NhbGU/OiBzdHJpbmdcbiAgYXNQYXRoOiBzdHJpbmdcbiAgcm91dGVyOiBSb3V0ZXJcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1hdGNoZXNNaWRkbGV3YXJlPFQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQ+KFxuICBvcHRpb25zOiBNaWRkbGV3YXJlRWZmZWN0UGFyYW1zPFQ+XG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoXG4gICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKClcbiAgKVxuICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lIH0gPSBwYXJzZVBhdGgob3B0aW9ucy5hc1BhdGgpXG4gIC8vIHJlbW92ZSBiYXNlUGF0aCBmaXJzdCBzaW5jZSBwYXRoIHByZWZpeCBoYXMgdG8gYmUgaW4gdGhlIG9yZGVyIG9mIGAvJHtiYXNlUGF0aH0vJHtsb2NhbGV9YFxuICBjb25zdCBjbGVhbmVkQXMgPSBoYXNCYXNlUGF0aChhc1BhdGhuYW1lKVxuICAgID8gcmVtb3ZlQmFzZVBhdGgoYXNQYXRobmFtZSlcbiAgICA6IGFzUGF0aG5hbWVcbiAgY29uc3QgYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUgPSBhZGRCYXNlUGF0aChcbiAgICBhZGRMb2NhbGUoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSlcbiAgKVxuXG4gIC8vIENoZWNrIG9ubHkgcGF0aCBtYXRjaCBvbiBjbGllbnQuIE1hdGNoaW5nIFwiaGFzXCIgc2hvdWxkIGJlIGRvbmUgb24gc2VydmVyXG4gIC8vIHdoZXJlIHdlIGNhbiBhY2Nlc3MgbW9yZSBpbmZvIHN1Y2ggYXMgaGVhZGVycywgSHR0cE9ubHkgY29va2llLCBldGMuXG4gIHJldHVybiBtYXRjaGVycy5zb21lKChtKSA9PlxuICAgIG5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpXG4gIClcbn1cblxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuXG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybFxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM/OiBVcmwpIHtcbiAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlciwgdXJsLCB0cnVlKVxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIGNvbnN0IGhyZWZXYXNBYnNvbHV0ZSA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbilcbiAgY29uc3QgYXNXYXNBYnNvbHV0ZSA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbilcblxuICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpXG4gIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzXG5cbiAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmV2FzQWJzb2x1dGUgPyByZXNvbHZlZEhyZWYgOiBhZGRCYXNlUGF0aChyZXNvbHZlZEhyZWYpXG4gIGNvbnN0IHByZXBhcmVkQXMgPSBhc1xuICAgID8gc3RyaXBPcmlnaW4ocmVzb2x2ZUhyZWYocm91dGVyLCBhcykpXG4gICAgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuXG4gIHJldHVybiB7XG4gICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICBhczogYXNXYXNBYnNvbHV0ZSA/IHByZXBhcmVkQXMgOiBhZGRCYXNlUGF0aChwcmVwYXJlZEFzKSxcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lOiBzdHJpbmcsIHBhZ2VzOiBzdHJpbmdbXSkge1xuICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChkZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhdGhuYW1lKSlcbiAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICByZXR1cm4gcGF0aG5hbWVcbiAgfVxuXG4gIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICBwYWdlcy5zb21lKChwYWdlKSA9PiB7XG4gICAgICBpZiAoaXNEeW5hbWljUm91dGUocGFnZSkgJiYgZ2V0Um91dGVSZWdleChwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIHBhdGhuYW1lID0gcGFnZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG59XG5cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVEYXRhPFQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQ+KFxuICBzb3VyY2U6IHN0cmluZyxcbiAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICBvcHRpb25zOiBNaWRkbGV3YXJlRWZmZWN0UGFyYW1zPFQ+XG4pIHtcbiAgY29uc3QgbmV4dENvbmZpZyA9IHtcbiAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXG4gICAgaTE4bjogeyBsb2NhbGVzOiBvcHRpb25zLnJvdXRlci5sb2NhbGVzIH0sXG4gICAgdHJhaWxpbmdTbGFzaDogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpLFxuICB9XG4gIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtcmV3cml0ZScpXG5cbiAgbGV0IHJld3JpdGVUYXJnZXQgPVxuICAgIHJld3JpdGVIZWFkZXIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLW1hdGNoZWQtcGF0aCcpXG5cbiAgY29uc3QgbWF0Y2hlZFBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldChNQVRDSEVEX1BBVEhfSEVBREVSKVxuXG4gIGlmIChcbiAgICBtYXRjaGVkUGF0aCAmJlxuICAgICFyZXdyaXRlVGFyZ2V0ICYmXG4gICAgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKCdfX25leHRfZGF0YV9jYXRjaGFsbCcpICYmXG4gICAgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKCcvX2Vycm9yJykgJiZcbiAgICAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy80MDQnKVxuICApIHtcbiAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICByZXdyaXRlVGFyZ2V0ID0gbWF0Y2hlZFBhdGhcbiAgfVxuXG4gIGlmIChyZXdyaXRlVGFyZ2V0KSB7XG4gICAgaWYgKFxuICAgICAgcmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKCcvJykgfHxcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRVxuICAgICkge1xuICAgICAgY29uc3QgcGFyc2VkUmV3cml0ZVRhcmdldCA9IHBhcnNlUmVsYXRpdmVVcmwocmV3cml0ZVRhcmdldClcbiAgICAgIGNvbnN0IHBhdGhuYW1lSW5mbyA9IGdldE5leHRQYXRobmFtZUluZm8ocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICBwYXJzZURhdGE6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBsZXQgZnNQYXRobmFtZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWVJbmZvLnBhdGhuYW1lKVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksXG4gICAgICBdKS50aGVuKChbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgfV06IGFueSkgPT4ge1xuICAgICAgICBsZXQgYXMgPSBhZGRMb2NhbGUocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0R5bmFtaWNSb3V0ZShhcykgfHxcbiAgICAgICAgICAoIXJld3JpdGVIZWFkZXIgJiZcbiAgICAgICAgICAgIHBhZ2VzLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoKHJlbW92ZUJhc2VQYXRoKGFzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcylcbiAgICAgICAgICAgICAgICAucGF0aG5hbWVcbiAgICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZFNvdXJjZSA9IGdldE5leHRQYXRobmFtZUluZm8oXG4gICAgICAgICAgICBwYXJzZVJlbGF0aXZlVXJsKHNvdXJjZSkucGF0aG5hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5leHRDb25maWc6IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVNcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcblxuICAgICAgICAgIGFzID0gYWRkQmFzZVBhdGgocGFyc2VkU291cmNlLnBhdGhuYW1lKVxuICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgICAgcmV3cml0ZXMsXG4gICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LFxuICAgICAgICAgICAgKHBhdGg6IHN0cmluZykgPT4gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRoLCBwYWdlcyksXG4gICAgICAgICAgICBvcHRpb25zLnJvdXRlci5sb2NhbGVzXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKHJlc3VsdC5tYXRjaGVkUGFnZSkge1xuICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IHJlc3VsdC5wYXJzZWRBcy5wYXRobmFtZVxuICAgICAgICAgICAgYXMgPSBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpXG5cbiAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRobmFtZSAhPT0gZnNQYXRobmFtZSkge1xuICAgICAgICAgICAgZnNQYXRobmFtZSA9IHJlc29sdmVkUGF0aG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSlcbiAgICAgICAgICA/IHJlc29sdmVEeW5hbWljUm91dGUoXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgICAgICAgcmVtb3ZlQmFzZVBhdGgocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSksXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICAgICAgICApLnBhdGhuYW1lLFxuICAgICAgICAgICAgICBwYWdlc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZnNQYXRobmFtZVxuXG4gICAgICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGdldFJvdXRlTWF0Y2hlcihnZXRSb3V0ZVJlZ2V4KHJlc29sdmVkSHJlZikpKGFzKVxuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3Jld3JpdGUnIGFzIGNvbnN0LFxuICAgICAgICAgIHBhcnNlZEFzOiBwYXJzZWRSZXdyaXRlVGFyZ2V0LFxuICAgICAgICAgIHJlc29sdmVkSHJlZixcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgY29uc3Qgc3JjID0gcGFyc2VQYXRoKHNvdXJjZSlcbiAgICBjb25zdCBwYXRobmFtZSA9IGZvcm1hdE5leHRQYXRobmFtZUluZm8oe1xuICAgICAgLi4uZ2V0TmV4dFBhdGhuYW1lSW5mbyhzcmMucGF0aG5hbWUsIHsgbmV4dENvbmZpZywgcGFyc2VEYXRhOiB0cnVlIH0pLFxuICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgIGJ1aWxkSWQ6ICcnLFxuICAgIH0pXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcgYXMgY29uc3QsXG4gICAgICBkZXN0aW5hdGlvbjogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgIH0pXG4gIH1cblxuICBjb25zdCByZWRpcmVjdFRhcmdldCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1yZWRpcmVjdCcpXG5cbiAgaWYgKHJlZGlyZWN0VGFyZ2V0KSB7XG4gICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgY29uc3Qgc3JjID0gcGFyc2VQYXRoKHJlZGlyZWN0VGFyZ2V0KVxuICAgICAgY29uc3QgcGF0aG5hbWUgPSBmb3JtYXROZXh0UGF0aG5hbWVJbmZvKHtcbiAgICAgICAgLi4uZ2V0TmV4dFBhdGhuYW1lSW5mbyhzcmMucGF0aG5hbWUsIHsgbmV4dENvbmZpZywgcGFyc2VEYXRhOiB0cnVlIH0pLFxuICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICBidWlsZElkOiAnJyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiAncmVkaXJlY3QtaW50ZXJuYWwnIGFzIGNvbnN0LFxuICAgICAgICBuZXdBczogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgICAgICBuZXdVcmw6IGAke3BhdGhuYW1lfSR7c3JjLnF1ZXJ5fSR7c3JjLmhhc2h9YCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICB0eXBlOiAncmVkaXJlY3QtZXh0ZXJuYWwnIGFzIGNvbnN0LFxuICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0LFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdHlwZTogJ25leHQnIGFzIGNvbnN0IH0pXG59XG5cbmludGVyZmFjZSBXaXRoTWlkZGxld2FyZUVmZmVjdHNPdXRwdXQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQge1xuICBlZmZlY3Q6IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgZ2V0TWlkZGxld2FyZURhdGE+PlxufVxuXG5hc3luYyBmdW5jdGlvbiB3aXRoTWlkZGxld2FyZUVmZmVjdHM8VCBleHRlbmRzIEZldGNoRGF0YU91dHB1dD4oXG4gIG9wdGlvbnM6IE1pZGRsZXdhcmVFZmZlY3RQYXJhbXM8VD5cbik6IFByb21pc2U8V2l0aE1pZGRsZXdhcmVFZmZlY3RzT3V0cHV0IHwgbnVsbD4ge1xuICBjb25zdCBtYXRjaGVzID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucylcbiAgaWYgKCFtYXRjaGVzIHx8ICFvcHRpb25zLmZldGNoRGF0YSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBkYXRhID0gYXdhaXQgb3B0aW9ucy5mZXRjaERhdGEoKVxuXG4gIGNvbnN0IGVmZmVjdCA9IGF3YWl0IGdldE1pZGRsZXdhcmVEYXRhKGRhdGEuZGF0YUhyZWYsIGRhdGEucmVzcG9uc2UsIG9wdGlvbnMpXG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhSHJlZjogZGF0YS5kYXRhSHJlZixcbiAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgdGV4dDogZGF0YS50ZXh0LFxuICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgIGVmZmVjdCxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBVcmwgPSBVcmxPYmplY3QgfCBzdHJpbmdcblxuZXhwb3J0IHR5cGUgQmFzZVJvdXRlciA9IHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZyB8IHVuZGVmaW5lZFxuICBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW10gfCB1bmRlZmluZWRcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZyB8IHVuZGVmaW5lZFxuICBkb21haW5Mb2NhbGVzPzogcmVhZG9ubHkgRG9tYWluTG9jYWxlW10gfCB1bmRlZmluZWRcbiAgaXNMb2NhbGVEb21haW46IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgTmV4dFJvdXRlciA9IEJhc2VSb3V0ZXIgJlxuICBQaWNrPFxuICAgIFJvdXRlcixcbiAgICB8ICdwdXNoJ1xuICAgIHwgJ3JlcGxhY2UnXG4gICAgfCAncmVsb2FkJ1xuICAgIHwgJ2JhY2snXG4gICAgfCAnZm9yd2FyZCdcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgICB8ICdpc1JlYWR5J1xuICAgIHwgJ2lzUHJldmlldydcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFByaXZhdGVSb3V0ZUluZm8gPVxuICB8IChPbWl0PENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ3N0eWxlU2hlZXRzJz4gJiB7IGluaXRpYWw6IHRydWUgfSlcbiAgfCBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm9cblxuZXhwb3J0IHR5cGUgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxuICByb3V0ZT86IHN0cmluZ1xuICByZXNvbHZlZEFzPzogc3RyaW5nXG4gIHF1ZXJ5PzogUGFyc2VkVXJsUXVlcnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHMgPSBQaWNrPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnZXJyJz4gJiB7XG4gIHJvdXRlcjogUm91dGVyXG59ICYgUmVjb3JkPHN0cmluZywgYW55PlxuZXhwb3J0IHR5cGUgQXBwQ29tcG9uZW50ID0gQ29tcG9uZW50VHlwZTxBcHBQcm9wcz5cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoXG4gIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gIEFwcDogQXBwQ29tcG9uZW50LFxuICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuKSA9PiBQcm9taXNlPHZvaWQ+XG5cbnR5cGUgQmVmb3JlUG9wU3RhdGVDYWxsYmFjayA9IChzdGF0ZTogTmV4dEhpc3RvcnlTdGF0ZSkgPT4gYm9vbGVhblxuXG50eXBlIENvbXBvbmVudExvYWRDYW5jZWwgPSAoKCkgPT4gdm9pZCkgfCBudWxsXG5cbnR5cGUgSGlzdG9yeU1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnIHwgJ3B1c2hTdGF0ZSdcblxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPVxuICBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gd2luZG93Lmhpc3RvcnkgJiZcbiAgISEoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgdiA9ICdfX25leHQnXG4gICAgICByZXR1cm4gKHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWUpXG4gICAgfSBjYXRjaCAobikge31cbiAgfSkoKVxuXG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woJ1NTR19EQVRBX05PVF9GT1VORCcpXG5cbmZ1bmN0aW9uIGZldGNoUmV0cnkoXG4gIHVybDogc3RyaW5nLFxuICBhdHRlbXB0czogbnVtYmVyLFxuICBvcHRpb25zOiBQaWNrPFJlcXVlc3RJbml0LCAnbWV0aG9kJyB8ICdoZWFkZXJzJz5cbik6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgJ3gtbmV4dGpzLWRhdGEnOiAnMScsXG4gICAgfSksXG4gIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgcmV0dXJuICFyZXNwb25zZS5vayAmJiBhdHRlbXB0cyA+IDEgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDUwMFxuICAgICAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKVxuICAgICAgOiByZXNwb25zZVxuICB9KVxufVxuXG5pbnRlcmZhY2UgRmV0Y2hEYXRhT3V0cHV0IHtcbiAgZGF0YUhyZWY6IHN0cmluZ1xuICBqc29uOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgbnVsbFxuICByZXNwb25zZTogUmVzcG9uc2VcbiAgdGV4dDogc3RyaW5nXG4gIGNhY2hlS2V5OiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIEZldGNoTmV4dERhdGFQYXJhbXMge1xuICBkYXRhSHJlZjogc3RyaW5nXG4gIGlzU2VydmVyUmVuZGVyOiBib29sZWFuXG4gIHBhcnNlSlNPTjogYm9vbGVhbiB8IHVuZGVmaW5lZFxuICBoYXNNaWRkbGV3YXJlPzogYm9vbGVhblxuICBpbmZsaWdodENhY2hlOiBOZXh0RGF0YUNhY2hlXG4gIHBlcnNpc3RDYWNoZTogYm9vbGVhblxuICBpc1ByZWZldGNoOiBib29sZWFuXG4gIGlzQmFja2dyb3VuZD86IGJvb2xlYW5cbiAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlPzogYm9vbGVhblxufVxuXG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKHtcbiAgZGF0YUhyZWYsXG4gIGluZmxpZ2h0Q2FjaGUsXG4gIGlzUHJlZmV0Y2gsXG4gIGhhc01pZGRsZXdhcmUsXG4gIGlzU2VydmVyUmVuZGVyLFxuICBwYXJzZUpTT04sXG4gIHBlcnNpc3RDYWNoZSxcbiAgaXNCYWNrZ3JvdW5kLFxuICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG59OiBGZXRjaE5leHREYXRhUGFyYW1zKTogUHJvbWlzZTxGZXRjaERhdGFPdXRwdXQ+IHtcbiAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIGNvbnN0IGdldERhdGEgPSAocGFyYW1zPzogeyBtZXRob2Q/OiAnSEVBRCcgfCAnR0VUJyB9KSA9PlxuICAgIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9IGFzIEhlYWRlcnNJbml0LFxuICAgICAgICBpc1ByZWZldGNoID8geyBwdXJwb3NlOiAncHJlZmV0Y2gnIH0gOiB7fSxcbiAgICAgICAgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8geyAneC1taWRkbGV3YXJlLXByZWZldGNoJzogJzEnIH0gOiB7fSxcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEXG4gICAgICAgICAgPyB7ICd4LWRlcGxveW1lbnQtaWQnOiBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQgfVxuICAgICAgICAgIDoge31cbiAgICAgICksXG4gICAgICBtZXRob2Q6IHBhcmFtcz8ubWV0aG9kID8/ICdHRVQnLFxuICAgIH0pXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIHBhcmFtcz8ubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhSHJlZiwgcmVzcG9uc2UsIHRleHQ6ICcnLCBqc29uOiB7fSwgY2FjaGVLZXkgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkYXRhIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QgYmVjYXVzZSBvZiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcbiAgICAgICAgICAgICAqIG1hcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIFRPRE86IENoYW5nZSB0aGUgc3RhdHVzIGNvZGUgaW4gdGhlIGhhbmRsZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZSAmJlxuICAgICAgICAgICAgICBbMzAxLCAzMDIsIDMwNywgMzA4XS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YUhyZWYsIHJlc3BvbnNlLCB0ZXh0LCBqc29uOiB7fSwgY2FjaGVLZXkgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgaWYgKHRyeVRvUGFyc2VBc0pTT04odGV4dCk/Lm5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAganNvbjogeyBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EIH0sXG4gICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xuICAgICAgICAgICAgICogYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgICAgICAgICBtYXJrQXNzZXRFcnJvcihlcnJvcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXBlcnNpc3RDYWNoZSB8fFxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgfHxcbiAgICAgICAgICBkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtY2FjaGUnKSA9PT0gJ25vLWNhY2hlJ1xuICAgICAgICApIHtcbiAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghdW5zdGFibGVfc2tpcENsaWVudENhY2hlKSB7XG4gICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldXG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIGNocm9tZVxuICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnRmFpbGVkIHRvIGZldGNoJyB8fFxuICAgICAgICAgIC8vIGZpcmVmb3hcbiAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJyB8fFxuICAgICAgICAgIC8vIHNhZmFyaVxuICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnTG9hZCBmYWlsZWQnXG4gICAgICAgICkge1xuICAgICAgICAgIG1hcmtBc3NldEVycm9yKGVycilcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG5cbiAgLy8gd2hlbiBza2lwcGluZyBjbGllbnQgY2FjaGUgd2Ugd2FpdCB0byB1cGRhdGVcbiAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXG4gIC8vIHRoaXMgYWxsb3dzIHJhY2luZyBjbGljayBldmVudCB3aXRoIGZldGNoaW5nIG5ld2VyIGRhdGFcbiAgLy8gd2l0aG91dCBibG9ja2luZyBuYXZpZ2F0aW9uIHdoZW4gc3RhbGUgZGF0YSBpcyBhdmFpbGFibGVcbiAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcbiAgICByZXR1cm4gZ2V0RGF0YSh7fSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1jYWNoZScpICE9PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIGNhY2hlIGlmIG5vdCBtYXJrZWQgYXMgbm8tY2FjaGVcbiAgICAgICAgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV1cbiAgfVxuICByZXR1cm4gKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gZ2V0RGF0YShcbiAgICBpc0JhY2tncm91bmQgPyB7IG1ldGhvZDogJ0hFQUQnIH0gOiB7fVxuICApKVxufVxuXG5pbnRlcmZhY2UgTmV4dERhdGFDYWNoZSB7XG4gIFthc1BhdGg6IHN0cmluZ106IFByb21pc2U8RmV0Y2hEYXRhT3V0cHV0PlxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgMTApXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgdXJsLFxuICByb3V0ZXIsXG59OiB7XG4gIHVybDogc3RyaW5nXG4gIHJvdXRlcjogUm91dGVyXG59KSB7XG4gIC8vIGVuc3VyZSB3ZSBkb24ndCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lXG4gIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXG4gIGlmICh1cmwgPT09IGFkZEJhc2VQYXRoKGFkZExvY2FsZShyb3V0ZXIuYXNQYXRoLCByb3V0ZXIubG9jYWxlKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gaGFyZCBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBVUkwgJHt1cmx9ICR7bG9jYXRpb24uaHJlZn1gXG4gICAgKVxuICB9XG4gIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsXG59XG5cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAoe1xuICByb3V0ZSxcbiAgcm91dGVyLFxufToge1xuICByb3V0ZTogc3RyaW5nXG4gIHJvdXRlcjogUm91dGVyXG59KSA9PiB7XG4gIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICBjb25zdCBjYW5jZWwgPSAocm91dGVyLmNsYyA9ICgpID0+IHtcbiAgICBjYW5jZWxsZWQgPSB0cnVlXG4gIH0pXG5cbiAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gKCkgPT4ge1xuICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgXG4gICAgICApXG4gICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGlmIChjYW5jZWwgPT09IHJvdXRlci5jbGMpIHtcbiAgICAgIHJvdXRlci5jbGMgPSBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBoYW5kbGVDYW5jZWxsZWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIGltcGxlbWVudHMgQmFzZVJvdXRlciB7XG4gIGJhc2VQYXRoOiBzdHJpbmdcblxuICAvKipcbiAgICogTWFwIG9mIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiBgUm91dGVyYFxuICAgKi9cbiAgY29tcG9uZW50czogeyBbcGF0aG5hbWU6IHN0cmluZ106IFByaXZhdGVSb3V0ZUluZm8gfVxuICAvLyBTZXJ2ZXIgRGF0YSBDYWNoZSAoZnVsbCBkYXRhIHJlcXVlc3RzKVxuICBzZGM6IE5leHREYXRhQ2FjaGUgPSB7fVxuICAvLyBTZXJ2ZXIgQmFja2dyb3VuZCBDYWNoZSAoSEVBRCByZXF1ZXN0cylcbiAgc2JjOiBOZXh0RGF0YUNhY2hlID0ge31cblxuICBzdWI6IFN1YnNjcmlwdGlvblxuICBjbGM6IENvbXBvbmVudExvYWRDYW5jZWxcbiAgcGFnZUxvYWRlcjogUGFnZUxvYWRlclxuICBfYnBzOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrIHwgdW5kZWZpbmVkXG4gIGV2ZW50czogTWl0dEVtaXR0ZXI8Um91dGVyRXZlbnQ+XG4gIF93cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICBpc1NzcjogYm9vbGVhblxuICBfaW5GbGlnaHRSb3V0ZT86IHN0cmluZyB8IHVuZGVmaW5lZFxuICBfc2hhbGxvdz86IGJvb2xlYW4gfCB1bmRlZmluZWRcbiAgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdIHwgdW5kZWZpbmVkXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgZG9tYWluTG9jYWxlcz86IHJlYWRvbmx5IERvbWFpbkxvY2FsZVtdIHwgdW5kZWZpbmVkXG4gIGlzUmVhZHk6IGJvb2xlYW5cbiAgaXNMb2NhbGVEb21haW46IGJvb2xlYW5cbiAgaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSB0cnVlXG4gIF9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlOiBQcm9taXNlPGJvb2xlYW4+XG4gIC8vIHN0YXRpYyBlbnRyaWVzIGZpbHRlclxuICBfYmZsX3M/OiBpbXBvcnQoJy4uLy4uL2xpYi9ibG9vbS1maWx0ZXInKS5CbG9vbUZpbHRlclxuICAvLyBkeW5hbWljIGVudGlyZXMgZmlsdGVyXG4gIF9iZmxfZD86IGltcG9ydCgnLi4vLi4vbGliL2Jsb29tLWZpbHRlcicpLkJsb29tRmlsdGVyXG5cbiAgcHJpdmF0ZSBzdGF0ZTogUmVhZG9ubHk8e1xuICAgIHJvdXRlOiBzdHJpbmdcbiAgICBwYXRobmFtZTogc3RyaW5nXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gICAgYXNQYXRoOiBzdHJpbmdcbiAgICBsb2NhbGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgICBpc1ByZXZpZXc6IGJvb2xlYW5cbiAgfT5cblxuICBwcml2YXRlIF9rZXk6IHN0cmluZyA9IGNyZWF0ZUtleSgpXG5cbiAgc3RhdGljIGV2ZW50czogTWl0dEVtaXR0ZXI8Um91dGVyRXZlbnQ+ID0gbWl0dCgpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICB7XG4gICAgICBpbml0aWFsUHJvcHMsXG4gICAgICBwYWdlTG9hZGVyLFxuICAgICAgQXBwLFxuICAgICAgd3JhcEFwcCxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIGVycixcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsb2NhbGUsXG4gICAgICBsb2NhbGVzLFxuICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgIGRvbWFpbkxvY2FsZXMsXG4gICAgICBpc1ByZXZpZXcsXG4gICAgfToge1xuICAgICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb25cbiAgICAgIGluaXRpYWxQcm9wczogYW55XG4gICAgICBwYWdlTG9hZGVyOiBhbnlcbiAgICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgQXBwOiBBcHBDb21wb25lbnRcbiAgICAgIHdyYXBBcHA6IChXcmFwQXBwQ29tcG9uZW50OiBBcHBDb21wb25lbnQpID0+IGFueVxuICAgICAgZXJyPzogRXJyb3JcbiAgICAgIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgICAgIGxvY2FsZT86IHN0cmluZ1xuICAgICAgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdXG4gICAgICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gICAgICBkb21haW5Mb2NhbGVzPzogcmVhZG9ubHkgRG9tYWluTG9jYWxlW11cbiAgICAgIGlzUHJldmlldz86IGJvb2xlYW5cbiAgICB9XG4gICkge1xuICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0ge1xuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgIGVycixcbiAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0ge1xuICAgICAgQ29tcG9uZW50OiBBcHAgYXMgQ29tcG9uZW50VHlwZSxcbiAgICAgIHN0eWxlU2hlZXRzOiBbXG4gICAgICAgIC8qIC9fYXBwIGRvZXMgbm90IG5lZWQgaXRzIHN0eWxlc2hlZXRzIG1hbmFnZWQgKi9cbiAgICAgIF0sXG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlclxuICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9XG4gICAgICBpc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnRcblxuICAgIHRoaXMuYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnXG4gICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb25cbiAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcFxuICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgIHRoaXMuaXNTc3IgPSB0cnVlXG4gICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlXG4gICAgdGhpcy5pc1JlYWR5ID0gISEoXG4gICAgICBzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmlzRXhwZXJpbWVudGFsQ29tcGlsZSB8fFxuICAgICAgKHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3ApIHx8XG4gICAgICAoIWF1dG9FeHBvcnREeW5hbWljICYmXG4gICAgICAgICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJlxuICAgICAgICAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUylcbiAgICApXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlc1xuICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZVxuICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlc1xuICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9ICEhZGV0ZWN0RG9tYWluTG9jYWxlKFxuICAgICAgICBkb21haW5Mb2NhbGVzLFxuICAgICAgICBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHJvdXRlLFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBxdWVyeSxcbiAgICAgIGFzUGF0aDogYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzLFxuICAgICAgaXNQcmV2aWV3OiAhIWlzUHJldmlldyxcbiAgICAgIGxvY2FsZTogcHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCA/IGxvY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShmYWxzZSlcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoIWFzLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0geyBsb2NhbGUgfVxuICAgICAgICBjb25zdCBhc1BhdGggPSBnZXRVUkwoKVxuXG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICBhc1BhdGgsXG4gICAgICAgIH0pLnRoZW4oKG1hdGNoZXMpID0+IHtcbiAgICAgICAgICAvLyBpZiBtaWRkbGV3YXJlIG1hdGNoZXMgd2UgbGVhdmUgcmVzb2x2aW5nIHRvIHRoZSBjaGFuZ2UgZnVuY3Rpb25cbiAgICAgICAgICAvLyBhcyB0aGUgc2VydmVyIG5lZWRzIHRvIHJlc29sdmUgZm9yIGNvcnJlY3QgcHJpb3JpdHlcbiAgICAgICAgICA7KG9wdGlvbnMgYXMgYW55KS5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhcyAhPT0gcGF0aG5hbWVcblxuICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgICAgICAgPyBhc1BhdGhcbiAgICAgICAgICAgICAgOiBmb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBtYXRjaGVzXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcblxuICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3QgeyBpc0ZpcnN0UG9wU3RhdGVFdmVudCB9ID0gdGhpc1xuICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSBmYWxzZVxuXG4gICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlIGFzIEhpc3RvcnlTdGF0ZVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICBpZiAoc3RhdGUuX19OQSkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gU2FmYXJpIGZpcmVzIHBvcHN0YXRlZXZlbnQgd2hlbiByZW9wZW5pbmcgdGhlIGJyb3dzZXIuXG4gICAgaWYgKFxuICAgICAgaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiZcbiAgICAgIHRoaXMubG9jYWxlID09PSBzdGF0ZS5vcHRpb25zLmxvY2FsZSAmJlxuICAgICAgc3RhdGUuYXMgPT09IHRoaXMuYXNQYXRoXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZm9yY2VkU2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCB1bmRlZmluZWRcbiAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMsIGtleSB9ID0gc3RhdGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9rZXkgIT09IGtleSkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5fa2V5LFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGNhdGNoIHt9XG5cbiAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBrZXkpXG4gICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYhKVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0geyB4OiAwLCB5OiAwIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fa2V5ID0ga2V5XG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmIChcbiAgICAgIHRoaXMuaXNTc3IgJiZcbiAgICAgIGFzID09PSBhZGRCYXNlUGF0aCh0aGlzLmFzUGF0aCkgJiZcbiAgICAgIHBhdGhuYW1lID09PSBhZGRCYXNlUGF0aCh0aGlzLnBhdGhuYW1lKVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2UoXG4gICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgIHVybCxcbiAgICAgIGFzLFxuICAgICAgT2JqZWN0LmFzc2lnbjx7fSwgVHJhbnNpdGlvbk9wdGlvbnMsIFRyYW5zaXRpb25PcHRpb25zPih7fSwgb3B0aW9ucywge1xuICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdmFsdWUgbm90IGV4cG9zZWQgb24gdHlwZXNcbiAgICAgICAgX2g6IDAsXG4gICAgICB9KSxcbiAgICAgIGZvcmNlZFNjcm9sbFxuICAgIClcbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogR28gZm9yd2FyZCBpbiBoaXN0b3J5XG4gICAqL1xuICBmb3J3YXJkKCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICBwdXNoKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSB3aGVuIHdlIHVwZGF0ZSBoaXN0b3J5IGJlZm9yZSByb3V0ZSBjaGFuZ2VcbiAgICAgIC8vIGlzIGNvbXBsZXRlLCBhcyB0aGUgcG9wc3RhdGUgZXZlbnQgc2hvdWxkIGhhbmRsZSB0aGlzIGNhcHR1cmUuXG4gICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTbmFwc2hvdCBzY3JvbGwgcG9zaXRpb24gcmlnaHQgYmVmb3JlIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZTpcbiAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2tleSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgeDogc2VsZi5wYWdlWE9mZnNldCwgeTogc2VsZi5wYWdlWU9mZnNldCB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH1cbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncHVzaFN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcmVwbGFjZSh1cmw6IFVybCwgYXM/OiBVcmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIF9iZmwoXG4gICAgYXM6IHN0cmluZyxcbiAgICByZXNvbHZlZEFzPzogc3RyaW5nLFxuICAgIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICAgIHNraXBOYXZpZ2F0ZT86IGJvb2xlYW5cbiAgKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICBpZiAoIXRoaXMuX2JmbF9zICYmICF0aGlzLl9iZmxfZCkge1xuICAgICAgICBjb25zdCB7IEJsb29tRmlsdGVyIH0gPVxuICAgICAgICAgIHJlcXVpcmUoJy4uLy4uL2xpYi9ibG9vbS1maWx0ZXInKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJylcblxuICAgICAgICB0eXBlIEZpbHRlciA9IFJldHVyblR5cGU8XG4gICAgICAgICAgaW1wb3J0KCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJykuQmxvb21GaWx0ZXJbJ2V4cG9ydCddXG4gICAgICAgID5cbiAgICAgICAgbGV0IHN0YXRpY0ZpbHRlckRhdGE6IEZpbHRlciB8IHVuZGVmaW5lZFxuICAgICAgICBsZXQgZHluYW1pY0ZpbHRlckRhdGE6IEZpbHRlciB8IHVuZGVmaW5lZFxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgOyh7XG4gICAgICAgICAgICBfX3JvdXRlckZpbHRlclN0YXRpYzogc3RhdGljRmlsdGVyRGF0YSxcbiAgICAgICAgICAgIF9fcm91dGVyRmlsdGVyRHluYW1pYzogZHluYW1pY0ZpbHRlckRhdGEsXG4gICAgICAgICAgfSA9IChhd2FpdCBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpIGFzIGFueSBhcyB7XG4gICAgICAgICAgICBfX3JvdXRlckZpbHRlclN0YXRpYz86IEZpbHRlclxuICAgICAgICAgICAgX19yb3V0ZXJGaWx0ZXJEeW5hbWljPzogRmlsdGVyXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbGVkIHRvIGxvYWQgYnVpbGQgbWFuaWZlc3QgaGFyZCBuYXZpZ2F0ZVxuICAgICAgICAgIC8vIHRvIGJlIHNhZmVcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICBpZiAoc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICB1cmw6IGFkZEJhc2VQYXRoKFxuICAgICAgICAgICAgICBhZGRMb2NhbGUoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvdXRlckZpbHRlclNWYWx1ZTogRmlsdGVyIHwgZmFsc2UgPSBwcm9jZXNzLmVudlxuICAgICAgICAgIC5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUiBhcyBhbnlcblxuICAgICAgICBpZiAoIXN0YXRpY0ZpbHRlckRhdGEgJiYgcm91dGVyRmlsdGVyU1ZhbHVlKSB7XG4gICAgICAgICAgc3RhdGljRmlsdGVyRGF0YSA9IHJvdXRlckZpbHRlclNWYWx1ZSA/IHJvdXRlckZpbHRlclNWYWx1ZSA6IHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm91dGVyRmlsdGVyRFZhbHVlOiBGaWx0ZXIgfCBmYWxzZSA9IHByb2Nlc3MuZW52XG4gICAgICAgICAgLl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIGFzIGFueVxuXG4gICAgICAgIGlmICghZHluYW1pY0ZpbHRlckRhdGEgJiYgcm91dGVyRmlsdGVyRFZhbHVlKSB7XG4gICAgICAgICAgZHluYW1pY0ZpbHRlckRhdGEgPSByb3V0ZXJGaWx0ZXJEVmFsdWVcbiAgICAgICAgICAgID8gcm91dGVyRmlsdGVyRFZhbHVlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGE/Lm51bUhhc2hlcykge1xuICAgICAgICAgIHRoaXMuX2JmbF9zID0gbmV3IEJsb29tRmlsdGVyKFxuICAgICAgICAgICAgc3RhdGljRmlsdGVyRGF0YS5udW1JdGVtcyxcbiAgICAgICAgICAgIHN0YXRpY0ZpbHRlckRhdGEuZXJyb3JSYXRlXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuX2JmbF9zLmltcG9ydChzdGF0aWNGaWx0ZXJEYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhPy5udW1IYXNoZXMpIHtcbiAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihcbiAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJEYXRhLm51bUl0ZW1zLFxuICAgICAgICAgICAgZHluYW1pY0ZpbHRlckRhdGEuZXJyb3JSYXRlXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuX2JmbF9kLmltcG9ydChkeW5hbWljRmlsdGVyRGF0YSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlXG4gICAgICBsZXQgbWF0Y2hlc0JmbER5bmFtaWMgPSBmYWxzZVxuICAgICAgY29uc3QgcGF0aHNUb0NoZWNrOiBBcnJheTx7IGFzPzogc3RyaW5nOyBhbGxvd01hdGNoQ3VycmVudD86IGJvb2xlYW4gfT4gPVxuICAgICAgICBbeyBhcyB9LCB7IGFzOiByZXNvbHZlZEFzIH1dXG5cbiAgICAgIGZvciAoY29uc3QgeyBhczogY3VyQXMsIGFsbG93TWF0Y2hDdXJyZW50IH0gb2YgcGF0aHNUb0NoZWNrKSB7XG4gICAgICAgIGlmIChjdXJBcykge1xuICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9IHJlbW92ZVRyYWlsaW5nU2xhc2goXG4gICAgICAgICAgICBuZXcgVVJMKGN1ckFzLCAnaHR0cDovL24nKS5wYXRobmFtZVxuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSBhZGRCYXNlUGF0aChcbiAgICAgICAgICAgIGFkZExvY2FsZShhc05vU2xhc2gsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSlcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBhbGxvd01hdGNoQ3VycmVudCB8fFxuICAgICAgICAgICAgYXNOb1NsYXNoICE9PVxuICAgICAgICAgICAgICByZW1vdmVUcmFpbGluZ1NsYXNoKG5ldyBVUkwodGhpcy5hc1BhdGgsICdodHRwOi8vbicpLnBhdGhuYW1lKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbWF0Y2hlc0JmbFN0YXRpYyA9XG4gICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgfHxcbiAgICAgICAgICAgICAgISF0aGlzLl9iZmxfcz8uY29udGFpbnMoYXNOb1NsYXNoKSB8fFxuICAgICAgICAgICAgICAhIXRoaXMuX2JmbF9zPy5jb250YWlucyhhc05vU2xhc2hMb2NhbGUpXG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEFTIG9mIFthc05vU2xhc2gsIGFzTm9TbGFzaExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgLy8gaWYgYW55IHN1Yi1wYXRoIG9mIGFzIG1hdGNoZXMgYSBkeW5hbWljIGZpbHRlciBwYXRoXG4gICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBoYXJkIG5hdmlnYXRlZFxuICAgICAgICAgICAgICBjb25zdCBjdXJBc1BhcnRzID0gbm9ybWFsaXplZEFTLnNwbGl0KCcvJylcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgIW1hdGNoZXNCZmxEeW5hbWljICYmIGkgPCBjdXJBc1BhcnRzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0ID0gY3VyQXNQYXJ0cy5zbGljZSgwLCBpKS5qb2luKCcvJylcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgdGhpcy5fYmZsX2Q/LmNvbnRhaW5zKGN1cnJlbnRQYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hlc0JmbER5bmFtaWMgPSB0cnVlXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IHJvdXRlciBmaWx0ZXIgaXMgbWF0Y2hlZCB0aGVuIHdlIHRyaWdnZXJcbiAgICAgICAgICAgIC8vIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICBpZiAobWF0Y2hlc0JmbFN0YXRpYyB8fCBtYXRjaGVzQmZsRHluYW1pYykge1xuICAgICAgICAgICAgICBpZiAoc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhZGRCYXNlUGF0aChcbiAgICAgICAgICAgICAgICAgIGFkZExvY2FsZShhcywgbG9jYWxlIHx8IHRoaXMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNoYW5nZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyxcbiAgICBmb3JjZWRTY3JvbGw/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybCkpIHtcbiAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsLCByb3V0ZXI6IHRoaXMgfSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgIGNvbnN0IGlzUXVlcnlVcGRhdGluZyA9IChvcHRpb25zIGFzIGFueSkuX2ggPT09IDFcblxuICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgdW5kZWZpbmVkLCBvcHRpb25zLmxvY2FsZSlcbiAgICB9XG5cbiAgICBsZXQgc2hvdWxkUmVzb2x2ZUhyZWYgPVxuICAgICAgaXNRdWVyeVVwZGF0aW5nIHx8XG4gICAgICAob3B0aW9ucyBhcyBhbnkpLl9zaG91bGRSZXNvbHZlSHJlZiB8fFxuICAgICAgcGFyc2VQYXRoKHVybCkucGF0aG5hbWUgPT09IHBhcnNlUGF0aChhcykucGF0aG5hbWVcblxuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgfVxuXG4gICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgLy8gb3IgYSBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZFxuICAgIGNvbnN0IHJlYWR5U3RhdGVDaGFuZ2UgPSB0aGlzLmlzUmVhZHkgIT09IHRydWVcbiAgICB0aGlzLmlzUmVhZHkgPSB0cnVlXG4gICAgY29uc3QgaXNTc3IgPSB0aGlzLmlzU3NyXG5cbiAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gaWYgYSByb3V0ZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYmVmb3JlXG4gICAgLy8gdGhlIHF1ZXJ5IHVwZGF0aW5nIGlzIHRyaWdnZXJlZCBpZ25vcmUgcXVlcnkgdXBkYXRpbmdcbiAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMuY2xjKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2VcbiAgICAgICAgICA/IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgIDogb3B0aW9ucy5sb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGVcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKFxuICAgICAgICBoYXNCYXNlUGF0aChhcykgPyByZW1vdmVCYXNlUGF0aChhcykgOiBhc1xuICAgICAgKVxuICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGVcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXJzZWRBcy5wYXRobmFtZSlcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgoXG4gICAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgICAgIGhhc0Jhc2VQYXRoKHVybCkgPyByZW1vdmVCYXNlUGF0aCh1cmwpIDogdXJsLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgICAgKS5wYXRobmFtZVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICBpZiAoIXRoaXMubG9jYWxlcz8uaW5jbHVkZXMobmV4dFN0YXRlLmxvY2FsZSEpKSB7XG4gICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRMb2NhbGUocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpXG4gICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgdXJsOiBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyksXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBuZXh0U3RhdGUubG9jYWxlXG4gICAgICApXG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWRpZE5hdmlnYXRlICYmXG4gICAgICAgICAgZGV0ZWN0ZWREb21haW4gJiZcbiAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluICYmXG4gICAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9IHJlbW92ZUJhc2VQYXRoKGFzKVxuICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgIHVybDogYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke1xuICAgICAgICAgICAgICBkZXRlY3RlZERvbWFpbi5kb21haW5cbiAgICAgICAgICAgIH0ke2FkZEJhc2VQYXRoKFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgICA6IGAvJHtuZXh0U3RhdGUubG9jYWxlfWBcbiAgICAgICAgICAgICAgfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJ1xuICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgIGlmIChTVCkge1xuICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2hhbGxvdyA9IGZhbHNlLCBzY3JvbGwgPSB0cnVlIH0gPSBvcHRpb25zXG4gICAgY29uc3Qgcm91dGVQcm9wcyA9IHsgc2hhbGxvdyB9XG5cbiAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSAmJiB0aGlzLmNsYykge1xuICAgICAgaWYgKCFpc1Nzcikge1xuICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXG4gICAgICAgICAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAgICAgICAgIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSxcbiAgICAgICAgICB0aGlzLl9pbkZsaWdodFJvdXRlLFxuICAgICAgICAgIHJvdXRlUHJvcHNcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuXG4gICAgYXMgPSBhZGRCYXNlUGF0aChcbiAgICAgIGFkZExvY2FsZShcbiAgICAgICAgaGFzQmFzZVBhdGgoYXMpID8gcmVtb3ZlQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICAgIG9wdGlvbnMubG9jYWxlLFxuICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgIClcbiAgICApXG4gICAgY29uc3QgY2xlYW5lZEFzID0gcmVtb3ZlTG9jYWxlKFxuICAgICAgaGFzQmFzZVBhdGgoYXMpID8gcmVtb3ZlQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICBuZXh0U3RhdGUubG9jYWxlXG4gICAgKVxuICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhc1xuXG4gICAgY29uc3QgbG9jYWxlQ2hhbmdlID0gcHJldkxvY2FsZSAhPT0gbmV4dFN0YXRlLmxvY2FsZVxuXG4gICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG5cbiAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgIG5leHRTdGF0ZS5hc1BhdGggPSBjbGVhbmVkQXNcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2Nyb2xsOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcylcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0KG5leHRTdGF0ZSwgdGhpcy5jb21wb25lbnRzW25leHRTdGF0ZS5yb3V0ZV0sIG51bGwpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGlzRXJyb3IoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcbiAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFxuXG4gICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgbGV0IHBhZ2VzOiBzdHJpbmdbXSwgcmV3cml0ZXM6IGFueVxuICAgIHRyeSB7XG4gICAgICA7W3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLFxuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpLFxuICAgICAgXSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmw6IGFzLCByb3V0ZXI6IHRoaXMgfSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnXG4gICAgfVxuXG4gICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1xuXG4gICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgIHBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgID8gcmVtb3ZlVHJhaWxpbmdTbGFzaChyZW1vdmVCYXNlUGF0aChwYXRobmFtZSkpXG4gICAgICA6IHBhdGhuYW1lXG5cbiAgICBsZXQgcm91dGUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuICAgIGNvbnN0IHBhcnNlZEFzUGF0aG5hbWUgPSBhcy5zdGFydHNXaXRoKCcvJykgJiYgcGFyc2VSZWxhdGl2ZVVybChhcykucGF0aG5hbWVcblxuICAgIC8vIGlmIHdlIGRldGVjdGVkIHRoZSBwYXRoIGFzIGFwcCByb3V0ZSBkdXJpbmcgcHJlZmV0Y2hpbmdcbiAgICAvLyB0cmlnZ2VyIGhhcmQgbmF2aWdhdGlvblxuICAgIGlmICgodGhpcy5jb21wb25lbnRzW3BhdGhuYW1lXSBhcyBhbnkpPy5fX2FwcFJvdXRlcikge1xuICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmw6IGFzLCByb3V0ZXI6IHRoaXMgfSlcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICB9XG5cbiAgICBjb25zdCBpc01pZGRsZXdhcmVSZXdyaXRlID0gISEoXG4gICAgICBwYXJzZWRBc1BhdGhuYW1lICYmXG4gICAgICByb3V0ZSAhPT0gcGFyc2VkQXNQYXRobmFtZSAmJlxuICAgICAgKCFpc0R5bmFtaWNSb3V0ZShyb3V0ZSkgfHxcbiAgICAgICAgIWdldFJvdXRlTWF0Y2hlcihnZXRSb3V0ZVJlZ2V4KHJvdXRlKSkocGFyc2VkQXNQYXRobmFtZSkpXG4gICAgKVxuXG4gICAgLy8gd2UgZG9uJ3QgYXR0ZW1wdCByZXNvbHZlIGFzUGF0aCB3aGVuIHdlIG5lZWQgdG8gZXhlY3V0ZVxuICAgIC8vIG1pZGRsZXdhcmUgYXMgdGhlIHJlc29sdmluZyB3aWxsIG9jY3VyIHNlcnZlci1zaWRlXG4gICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPVxuICAgICAgIW9wdGlvbnMuc2hhbGxvdyAmJlxuICAgICAgKGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICB9KSlcblxuICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgIHNob3VsZFJlc29sdmVIcmVmID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgOyhvcHRpb25zIGFzIGFueSkuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLFxuICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgIHJld3JpdGVzLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIChwOiBzdHJpbmcpID0+IHJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLFxuICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICApXG5cbiAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBhcywgcm91dGVyOiB0aGlzIH0pXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmXG4gICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGF0aG5hbWUpXG5cbiAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcylcblxuICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG4gICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGF0aG5hbWUpXG5cbiAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArXG4gICAgICAgICAgICBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBhcywgcm91dGVyOiB0aGlzIH0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXNvbHZlZEFzID0gcmVtb3ZlTG9jYWxlKHJlbW92ZUJhc2VQYXRoKHJlc29sdmVkQXMpLCBuZXh0U3RhdGUubG9jYWxlKVxuXG4gICAgcm91dGUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuICAgIGxldCByb3V0ZU1hdGNoOiBQYXJhbXMgfCBmYWxzZSA9IGZhbHNlXG5cbiAgICBpZiAoaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcylcbiAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZVxuXG4gICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgIHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWVcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSlcbiAgICAgICAgOiAoe30gYXMgeyByZXN1bHQ6IHVuZGVmaW5lZDsgcGFyYW1zOiB1bmRlZmluZWQgfSlcblxuICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IChzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSkge1xuICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcihcbiAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV0gJiYgIXJvdXRlUmVnZXguZ3JvdXBzW3BhcmFtXS5vcHRpb25hbFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCAmJiAhaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyBgSW50ZXJwb2xhdGluZyBocmVmYFxuICAgICAgICAgICAgICAgICAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgXG4gICAgICAgICAgICAgIH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArXG4gICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgKHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgXG4gICAgICAgICAgICAgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgK1xuICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJ1xuICAgICAgICAgICAgICAgICAgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnXG4gICAgICAgICAgICAgIH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICBxdWVyeTogb21pdChxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zISksXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG4gICAgfVxuXG4gICAgY29uc3QgaXNFcnJvclJvdXRlID0gdGhpcy5wYXRobmFtZSA9PT0gJy80MDQnIHx8IHRoaXMucGF0aG5hbWUgPT09ICcvX2Vycm9yJ1xuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgaGFzTWlkZGxld2FyZTogaXNNaWRkbGV3YXJlTWF0Y2gsXG4gICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2ssXG4gICAgICAgIGlzTWlkZGxld2FyZVJld3JpdGUsXG4gICAgICB9KVxuXG4gICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2JmbChcbiAgICAgICAgICBhcyxcbiAgICAgICAgICAncmVzb2x2ZWRBcycgaW4gcm91dGVJbmZvID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmICgncm91dGUnIGluIHJvdXRlSW5mbyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICBwYXRobmFtZSA9IHJvdXRlSW5mby5yb3V0ZSB8fCByb3V0ZVxuICAgICAgICByb3V0ZSA9IHBhdGhuYW1lXG5cbiAgICAgICAgaWYgKCFyb3V0ZVByb3BzLnNoYWxsb3cpIHtcbiAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGVhbmVkUGFyc2VkUGF0aG5hbWUgPSBoYXNCYXNlUGF0aChwYXJzZWQucGF0aG5hbWUpXG4gICAgICAgICAgPyByZW1vdmVCYXNlUGF0aChwYXJzZWQucGF0aG5hbWUpXG4gICAgICAgICAgOiBwYXJzZWQucGF0aG5hbWVcblxuICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMocm91dGVNYXRjaCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBxdWVyeVtrZXldID09PSByb3V0ZU1hdGNoW2tleV0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSkge1xuICAgICAgICAgIGNvbnN0IHByZWZpeGVkQXMgPVxuICAgICAgICAgICAgIXJvdXRlUHJvcHMuc2hhbGxvdyAmJiByb3V0ZUluZm8ucmVzb2x2ZWRBc1xuICAgICAgICAgICAgICA/IHJvdXRlSW5mby5yZXNvbHZlZEFzXG4gICAgICAgICAgICAgIDogYWRkQmFzZVBhdGgoXG4gICAgICAgICAgICAgICAgICBhZGRMb2NhbGUoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoYXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgIGxldCByZXdyaXRlQXMgPSBwcmVmaXhlZEFzXG5cbiAgICAgICAgICBpZiAoaGFzQmFzZVBhdGgocmV3cml0ZUFzKSkge1xuICAgICAgICAgICAgcmV3cml0ZUFzID0gcmVtb3ZlQmFzZVBhdGgocmV3cml0ZUFzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKHJld3JpdGVBcywgdGhpcy5sb2NhbGVzKVxuICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlXG4gICAgICAgICAgICByZXdyaXRlQXMgPSBsb2NhbGVSZXN1bHQucGF0aG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocGF0aG5hbWUpXG4gICAgICAgICAgY29uc3QgY3VyUm91dGVNYXRjaCA9IGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShcbiAgICAgICAgICAgIG5ldyBVUkwocmV3cml0ZUFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZVxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChjdXJSb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCBjdXJSb3V0ZU1hdGNoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcm91dGVJbmZvIGJyaW5ncyBhIHJlZGlyZWN0IHdlIHNpbXBseSBhcHBseSBpdC5cbiAgICAgIGlmICgndHlwZScgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgIGlmIChyb3V0ZUluZm8udHlwZSA9PT0gJ3JlZGlyZWN0LWludGVybmFsJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIHJvdXRlSW5mby5uZXdVcmwsIHJvdXRlSW5mby5uZXdBcywgb3B0aW9ucylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogcm91dGVJbmZvLmRlc3RpbmF0aW9uLCByb3V0ZXI6IHRoaXMgfSlcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcG9uZW50OiBhbnkgPSByb3V0ZUluZm8uQ29tcG9uZW50XG4gICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpXG5cbiAgICAgICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQ6IGFueSkgPT4ge1xuICAgICAgICAgIGhhbmRsZUNsaWVudFNjcmlwdExvYWQoc2NyaXB0LnByb3BzKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgIGlmICgocm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1ApICYmIHJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcyAmJlxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZGVzdGluYXRpb24gZnJvbSByZWRpcmVjdCB3aXRob3V0IGFkZGluZyBsb2NhbGVcbiAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGZhbHNlXG5cbiAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG5cbiAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSAmJlxuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RfQkFTRV9QQVRIICE9PSBmYWxzZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9IHBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pXG4gICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShcbiAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSxcbiAgICAgICAgICAgICAgcGFnZXNcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXMoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucylcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmw6IGRlc3RpbmF0aW9uLCByb3V0ZXI6IHRoaXMgfSlcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICAgIH1cblxuICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVdcblxuICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XG4gICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlXG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnLzQwNCcpXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy80MDQnXG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvX2Vycm9yJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgIHJvdXRlOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgcGF0aG5hbWU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgIHJvdXRlUHJvcHM6IHsgc2hhbGxvdzogZmFsc2UgfSxcbiAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgIGlzTm90Rm91bmQ6IHRydWUsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmICgndHlwZScgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gLzQwNGApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgaXNRdWVyeVVwZGF0aW5nICYmXG4gICAgICAgIHRoaXMucGF0aG5hbWUgPT09ICcvX2Vycm9yJyAmJlxuICAgICAgICBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHM/LnBhZ2VQcm9wcz8uc3RhdHVzQ29kZSA9PT0gNTAwICYmXG4gICAgICAgIHJvdXRlSW5mby5wcm9wcz8ucGFnZVByb3BzXG4gICAgICApIHtcbiAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwXG4gICAgICB9XG5cbiAgICAgIC8vIHNoYWxsb3cgcm91dGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHNhbWUgcGFnZSBVUkwgY2hhbmdlcy5cbiAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPVxuICAgICAgICBvcHRpb25zLnNoYWxsb3cgJiYgbmV4dFN0YXRlLnJvdXRlID09PSAocm91dGVJbmZvLnJvdXRlID8/IHJvdXRlKVxuXG4gICAgICBjb25zdCBzaG91bGRTY3JvbGwgPVxuICAgICAgICBvcHRpb25zLnNjcm9sbCA/PyAoIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZSlcbiAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8geyB4OiAwLCB5OiAwIH0gOiBudWxsXG4gICAgICBjb25zdCB1cGNvbWluZ1Njcm9sbFN0YXRlID0gZm9yY2VkU2Nyb2xsID8/IHJlc2V0U2Nyb2xsXG5cbiAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgY29uc3QgdXBjb21pbmdSb3V0ZXJTdGF0ZSA9IHtcbiAgICAgICAgLi4ubmV4dFN0YXRlLFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhc1BhdGg6IGNsZWFuZWRBcyxcbiAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXG4gICAgICAvLyBxdWVyeSBwYXJhbWV0ZXJzLiBSb3V0ZSBjaGFuZ2VzIGhlcmUgbWlnaHQgYWRkIHRoZSBiYXNlUGF0aCB3aGVuIGl0XG4gICAgICAvLyB3YXNuJ3Qgb3JpZ2luYWxseSBwcmVzZW50LiBUaGlzIGlzIGFsc28gd2h5IHRoaXMgYmxvY2sgaXMgYmVmb3JlIHRoZVxuICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xuICAgICAgLy8gdGhlIFVSTCkuXG4gICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzRXJyb3JSb3V0ZSkge1xuICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgcm91dGU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgcGF0aG5hbWU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICByb3V0ZVByb3BzOiB7IHNoYWxsb3c6IGZhbHNlIH0sXG4gICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhdGhpcy5pc0ZhbGxiYWNrLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICgndHlwZScgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uICR7dGhpcy5wYXRobmFtZX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMucGF0aG5hbWUgPT09ICcvX2Vycm9yJyAmJlxuICAgICAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcz8ucGFnZVByb3BzPy5zdGF0dXNDb2RlID09PSA1MDAgJiZcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHM/LnBhZ2VQcm9wc1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGlzRXJyb3IoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcylcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuXG4gICAgICAvLyBmb3IgcXVlcnkgdXBkYXRlcyB3ZSBjYW4gc2tpcCBpdCBpZiB0aGUgc3RhdGUgaXMgdW5jaGFuZ2VkIGFuZCB3ZSBkb24ndFxuICAgICAgLy8gbmVlZCB0byBzY3JvbGxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzcxMzlcbiAgICAgIGNvbnN0IGNhblNraXBVcGRhdGluZyA9XG4gICAgICAgIGlzUXVlcnlVcGRhdGluZyAmJlxuICAgICAgICAhdXBjb21pbmdTY3JvbGxTdGF0ZSAmJlxuICAgICAgICAhcmVhZHlTdGF0ZUNoYW5nZSAmJlxuICAgICAgICAhbG9jYWxlQ2hhbmdlICYmXG4gICAgICAgIGNvbXBhcmVSb3V0ZXJTdGF0ZXModXBjb21pbmdSb3V0ZXJTdGF0ZSwgdGhpcy5zdGF0ZSlcblxuICAgICAgaWYgKCFjYW5Ta2lwVXBkYXRpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGVcbiAgICAgICAgICBlbHNlIHRocm93IGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3V0ZUluZm8uZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFxuICAgICAgICAgICAgICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICAgICAgICAgICAgIHJvdXRlSW5mby5lcnJvcixcbiAgICAgICAgICAgICAgY2xlYW5lZEFzLFxuICAgICAgICAgICAgICByb3V0ZVByb3BzXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgcm91dGVJbmZvLmVycm9yXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgIGlmIChuZXh0U3RhdGUubG9jYWxlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IG5leHRTdGF0ZS5sb2NhbGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXG4gICAgICAgIGNvbnN0IGhhc2hSZWdleCA9IC8jLiskL1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsICYmIGhhc2hSZWdleC50ZXN0KGFzKSkge1xuICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoaXNFcnJvcihlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgIGtleTogKHRoaXMuX2tleSA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9rZXkgOiBjcmVhdGVLZXkoKSksXG4gICAgICAgIH0gYXMgSGlzdG9yeVN0YXRlLFxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgJycsXG4gICAgICAgIGFzXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgZXJyOiBFcnJvciAmIHsgY29kZT86IGFueTsgY2FuY2VsbGVkPzogYm9vbGVhbiB9LFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzLFxuICAgIGxvYWRFcnJvckZhaWw/OiBib29sZWFuXG4gICk6IFByb21pc2U8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvPiB7XG4gICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoaXNBc3NldEVycm9yKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcywgcm91dGVQcm9wcylcblxuICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG5cbiAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICB1cmw6IGFzLFxuICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICB9KVxuXG4gICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKClcbiAgICB9XG5cbiAgICBjb25zb2xlLmVycm9yKGVycilcblxuICAgIHRyeSB7XG4gICAgICBsZXQgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWRcbiAgICAgIGNvbnN0IHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9ID1cbiAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnL19lcnJvcicpXG5cbiAgICAgIGNvbnN0IHJvdXRlSW5mbzogQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgZXJyLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB9IGFzIGFueSlcbiAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKVxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgICAgIGlzRXJyb3Iocm91dGVJbmZvRXJyKSA/IHJvdXRlSW5mb0VyciA6IG5ldyBFcnJvcihyb3V0ZUluZm9FcnIgKyAnJyksXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRSb3V0ZUluZm8oe1xuICAgIHJvdXRlOiByZXF1ZXN0ZWRSb3V0ZSxcbiAgICBwYXRobmFtZSxcbiAgICBxdWVyeSxcbiAgICBhcyxcbiAgICByZXNvbHZlZEFzLFxuICAgIHJvdXRlUHJvcHMsXG4gICAgbG9jYWxlLFxuICAgIGhhc01pZGRsZXdhcmUsXG4gICAgaXNQcmV2aWV3LFxuICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICBpc1F1ZXJ5VXBkYXRpbmcsXG4gICAgaXNNaWRkbGV3YXJlUmV3cml0ZSxcbiAgICBpc05vdEZvdW5kLFxuICB9OiB7XG4gICAgcm91dGU6IHN0cmluZ1xuICAgIHBhdGhuYW1lOiBzdHJpbmdcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgICBhczogc3RyaW5nXG4gICAgcmVzb2x2ZWRBczogc3RyaW5nXG4gICAgaGFzTWlkZGxld2FyZT86IGJvb2xlYW5cbiAgICByb3V0ZVByb3BzOiBSb3V0ZVByb3BlcnRpZXNcbiAgICBsb2NhbGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIGlzUHJldmlldzogYm9vbGVhblxuICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZT86IGJvb2xlYW5cbiAgICBpc1F1ZXJ5VXBkYXRpbmc/OiBib29sZWFuXG4gICAgaXNNaWRkbGV3YXJlUmV3cml0ZT86IGJvb2xlYW5cbiAgICBpc05vdEZvdW5kPzogYm9vbGVhblxuICB9KSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBgcm91dGVgIGJpbmRpbmcgY2FuIGNoYW5nZSBpZiB0aGVyZSdzIGEgcmV3cml0ZVxuICAgICAqIHNvIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHJlcXVlc3RlZCByb3V0ZVxuICAgICAqIHNvIHdlIGNhbiBzdG9yZSB0aGUgY2FjaGUgZm9yIGl0IGFuZCBhdm9pZCByZS1yZXF1ZXN0aW5nIGV2ZXJ5IHRpbWVcbiAgICAgKiBmb3Igc2hhbGxvdyByb3V0aW5nIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGxldCByb3V0ZSA9IHJlcXVlc3RlZFJvdXRlXG5cbiAgICB0cnkge1xuICAgICAgbGV0IGV4aXN0aW5nSW5mbzogUHJpdmF0ZVJvdXRlSW5mbyB8IHVuZGVmaW5lZCA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV1cbiAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0luZm9cbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7IHJvdXRlLCByb3V0ZXI6IHRoaXMgfSlcblxuICAgICAgaWYgKGhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgZXhpc3RpbmdJbmZvID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGxldCBjYWNoZWRSb3V0ZUluZm8gPVxuICAgICAgICBleGlzdGluZ0luZm8gJiZcbiAgICAgICAgISgnaW5pdGlhbCcgaW4gZXhpc3RpbmdJbmZvKSAmJlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50J1xuICAgICAgICAgID8gZXhpc3RpbmdJbmZvXG4gICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgY29uc3QgaXNCYWNrZ3JvdW5kID0gaXNRdWVyeVVwZGF0aW5nXG4gICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zOiBGZXRjaE5leHREYXRhUGFyYW1zID0ge1xuICAgICAgICBkYXRhSHJlZjogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICBocmVmOiBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyAnLzQwNCcgOiByZXNvbHZlZEFzLFxuICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgfSksXG4gICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgIGluZmxpZ2h0Q2FjaGU6IGlzQmFja2dyb3VuZCA/IHRoaXMuc2JjIDogdGhpcy5zZGMsXG4gICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgaXNCYWNrZ3JvdW5kLFxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YTpcbiAgICAgICAgfCBXaXRoTWlkZGxld2FyZUVmZmVjdHNPdXRwdXRcbiAgICAgICAgfCAoUGljazxXaXRoTWlkZGxld2FyZUVmZmVjdHNPdXRwdXQsICdqc29uJz4gJlxuICAgICAgICAgICAgT21pdDxQYXJ0aWFsPFdpdGhNaWRkbGV3YXJlRWZmZWN0c091dHB1dD4sICdqc29uJz4pXG4gICAgICAgIHwgbnVsbCA9XG4gICAgICAgIGlzUXVlcnlVcGRhdGluZyAmJiAhaXNNaWRkbGV3YXJlUmV3cml0ZVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKSA9PiBmZXRjaE5leHREYXRhKGZldGNoTmV4dERhdGFQYXJhbXMpLFxuICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyAnLzQwNCcgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXJkIGVycm9yIGR1cmluZyBxdWVyeSB1cGRhdGluZ1xuICAgICAgICAgICAgICAvLyBhcyBpdCdzIHVuLW5lY2Vzc2FyeSBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGZhdGFsXG4gICAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIGZhbGxiYWNrIHJvdXRlIGFuZCB0aGUgcHJvcHMgY2FuJ3RcbiAgICAgICAgICAgICAgLy8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgfSlcblxuICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcbiAgICAgIC8vIGVmZmVjdHNcbiAgICAgIGlmIChkYXRhICYmIChwYXRobmFtZSA9PT0gJy9fZXJyb3InIHx8IHBhdGhuYW1lID09PSAnLzQwNCcpKSB7XG4gICAgICAgIGRhdGEuZWZmZWN0ID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IHsganNvbjogc2VsZi5fX05FWFRfREFUQV9fLnByb3BzIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhLmpzb24gPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoYW5kbGVDYW5jZWxsZWQoKVxuXG4gICAgICBpZiAoXG4gICAgICAgIGRhdGE/LmVmZmVjdD8udHlwZSA9PT0gJ3JlZGlyZWN0LWludGVybmFsJyB8fFxuICAgICAgICBkYXRhPy5lZmZlY3Q/LnR5cGUgPT09ICdyZWRpcmVjdC1leHRlcm5hbCdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZGF0YS5lZmZlY3RcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGE/LmVmZmVjdD8udHlwZSA9PT0gJ3Jld3JpdGUnKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUm91dGUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZilcbiAgICAgICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuXG4gICAgICAgIC8vIGR1cmluZyBxdWVyeSB1cGRhdGluZyB0aGUgcGFnZSBtdXN0IG1hdGNoIGFsdGhvdWdoIGR1cmluZ1xuICAgICAgICAvLyBjbGllbnQtdHJhbnNpdGlvbiBhIHJlZGlyZWN0IHRoYXQgZG9lc24ndCBtYXRjaCBhIHBhZ2VcbiAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGFuZCB0aGlzIHNob3VsZCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgIC8vIHdoaWNoIGlzIHZhbGlkIGZvciBpbmNyZW1lbnRhbCBtaWdyYXRpb25cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgfHwgcGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRSb3V0ZSkpIHtcbiAgICAgICAgICByb3V0ZSA9IHJlc29sdmVkUm91dGVcbiAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZlxuICAgICAgICAgIHF1ZXJ5ID0geyAuLi5xdWVyeSwgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnkgfVxuICAgICAgICAgIHJlc29sdmVkQXMgPSByZW1vdmVCYXNlUGF0aChcbiAgICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcylcbiAgICAgICAgICAgICAgLnBhdGhuYW1lXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICBleGlzdGluZ0luZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcm91dGVQcm9wcy5zaGFsbG93ICYmXG4gICAgICAgICAgICBleGlzdGluZ0luZm8gJiZcbiAgICAgICAgICAgIHRoaXMucm91dGUgPT09IHJvdXRlICYmXG4gICAgICAgICAgICAhaGFzTWlkZGxld2FyZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIGN1cnJlbnQgcm91dGUgZHVlIHRvIHJld3JpdGUsXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29weSB0aGUgZXhpc3RpbmcgaW5mb3JtYXRpb24gdG8gdGhlIHJld3JpdHRlbiBvbmUuXG4gICAgICAgICAgICAvLyBUaGVuLCB3ZSByZXR1cm4gdGhlIGluZm9ybWF0aW9uIGFsb25nIHdpdGggdGhlIG1hdGNoZWQgcm91dGUuXG4gICAgICAgICAgICByZXR1cm4geyAuLi5leGlzdGluZ0luZm8sIHJvdXRlIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQVBJUm91dGUocm91dGUpKSB7XG4gICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBhcywgcm91dGVyOiB0aGlzIH0pXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxuZXZlcj4oKCkgPT4ge30pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvdXRlSW5mbyA9XG4gICAgICAgIGNhY2hlZFJvdXRlSW5mbyB8fFxuICAgICAgICAoYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbjxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+KFxuICAgICAgICAgIChyZXMpID0+ICh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUCxcbiAgICAgICAgICB9KVxuICAgICAgICApKVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID1cbiAgICAgICAgICByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKSBhcyB0eXBlb2YgaW1wb3J0KCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKVxuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShyb3V0ZUluZm8uQ29tcG9uZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhc0JhaWxlZFByZWZldGNoID0gZGF0YT8ucmVzcG9uc2U/LmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtc2tpcCcpXG5cbiAgICAgIGNvbnN0IHNob3VsZEZldGNoRGF0YSA9IHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQXG5cbiAgICAgIC8vIEZvciBub24tU1NHIHByZWZldGNoZXMgdGhhdCBiYWlsZWQgYmVmb3JlIHNlbmRpbmcgZGF0YVxuICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiBkYXRhPy5kYXRhSHJlZikge1xuICAgICAgICBkZWxldGUgdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl1cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBwcm9wcywgY2FjaGVLZXkgfSA9IGF3YWl0IHRoaXMuX2dldERhdGEoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkRmV0Y2hEYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGE/Lmpzb24gJiYgIXdhc0JhaWxlZFByZWZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjYWNoZUtleTogZGF0YS5jYWNoZUtleSwgcHJvcHM6IGRhdGEuanNvbiB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGF0YUhyZWYgPSBkYXRhPy5kYXRhSHJlZlxuICAgICAgICAgICAgPyBkYXRhLmRhdGFIcmVmXG4gICAgICAgICAgICA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgaHJlZjogZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbnN0IGZldGNoZWQgPSBhd2FpdCBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRoaXMuaXNTc3IsXG4gICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICBpbmZsaWdodENhY2hlOiB3YXNCYWlsZWRQcmVmZXRjaCA/IHt9IDogdGhpcy5zZGMsXG4gICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhY2hlS2V5OiBmZXRjaGVkLmNhY2hlS2V5LFxuICAgICAgICAgICAgcHJvcHM6IGZldGNoZWQuanNvbiB8fCB7fSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgIHByb3BzOiBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhcbiAgICAgICAgICAgIHJvdXRlSW5mby5Db21wb25lbnQsXG4gICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgbG9jYWxlczogdGhpcy5sb2NhbGVzLFxuICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICB9IGFzIGFueVxuICAgICAgICAgICksXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIE9ubHkgYnVzdCB0aGUgZGF0YSBjYWNoZSBmb3IgU1NQIHJvdXRlcyBhbHRob3VnaFxuICAgICAgLy8gbWlkZGxld2FyZSBjYW4gc2tpcCBjYWNoZSBwZXIgcmVxdWVzdCB3aXRoXG4gICAgICAvLyB4LW1pZGRsZXdhcmUtY2FjaGU6IG5vLWNhY2hlIGFzIHdlbGxcbiAgICAgIGlmIChyb3V0ZUluZm8uX19OX1NTUCAmJiBmZXRjaE5leHREYXRhUGFyYW1zLmRhdGFIcmVmICYmIGNhY2hlS2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tjYWNoZUtleV1cbiAgICAgIH1cblxuICAgICAgLy8gd2Uga2ljayBvZmYgYSBIRUFEIHJlcXVlc3QgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgIC8vIHdoZW4gYSBub24tcHJlZmV0Y2ggcmVxdWVzdCBpcyBtYWRlIHRvIHNpZ25hbCByZXZhbGlkYXRpb25cbiAgICAgIGlmIChcbiAgICAgICAgIXRoaXMuaXNQcmV2aWV3ICYmXG4gICAgICAgIHJvdXRlSW5mby5fX05fU1NHICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICAgICFpc1F1ZXJ5VXBkYXRpbmdcbiAgICAgICkge1xuICAgICAgICBmZXRjaE5leHREYXRhKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGZldGNoTmV4dERhdGFQYXJhbXMsIHtcbiAgICAgICAgICAgIGlzQmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNiYyxcbiAgICAgICAgICB9KVxuICAgICAgICApLmNhdGNoKCgpID0+IHt9KVxuICAgICAgfVxuXG4gICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpXG4gICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wc1xuICAgICAgcm91dGVJbmZvLnJvdXRlID0gcm91dGVcbiAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5XG4gICAgICByb3V0ZUluZm8ucmVzb2x2ZWRBcyA9IHJlc29sdmVkQXNcbiAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm9cblxuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgICAgIGdldFByb3BlckVycm9yKGVyciksXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJvdXRlUHJvcHNcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldChcbiAgICBzdGF0ZTogdHlwZW9mIHRoaXMuc3RhdGUsXG4gICAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGVcblxuICAgIHJldHVybiB0aGlzLnN1YihcbiAgICAgIGRhdGEsXG4gICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50IGFzIEFwcENvbXBvbmVudCxcbiAgICAgIHJlc2V0U2Nyb2xsXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBiZWZvcmVQb3BTdGF0ZShjYjogQmVmb3JlUG9wU3RhdGVDYWxsYmFjaykge1xuICAgIHRoaXMuX2JwcyA9IGNiXG4gIH1cblxuICBvbmx5QUhhc2hDaGFuZ2UoYXM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnLCAyKVxuICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnLCAyKVxuXG4gICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaFxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbLCBoYXNoID0gJyddID0gYXMuc3BsaXQoJyMnLCAyKVxuXG4gICAgZGlzYWJsZVNtb290aFNjcm9sbER1cmluZ1JvdXRlVHJhbnNpdGlvbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgaWYgKGhhc2ggPT09ICcnIHx8IGhhc2ggPT09ICd0b3AnKSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXG4gICAgICAgIGNvbnN0IHJhd0hhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaClcbiAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhd0hhc2gpXG4gICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXVxuICAgICAgICBpZiAobmFtZUVsKSB7XG4gICAgICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgb25seUhhc2hDaGFuZ2U6IHRoaXMub25seUFIYXNoQ2hhbmdlKGFzKSxcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICB1cmxJc05ldyhhc1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoXG4gIH1cblxuICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqL1xuICBhc3luYyBwcmVmZXRjaChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhc1BhdGg6IHN0cmluZyA9IHVybCxcbiAgICBvcHRpb25zOiBQcmVmZXRjaE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBpc0JvdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIC8vIE5vIHByZWZldGNoZXMgZm9yIGJvdHMgdGhhdCByZW5kZXIgdGhlIGxpbmsgc2luY2UgdGhleSBhcmUgdHlwaWNhbGx5IG5hdmlnYXRpbmdcbiAgICAgIC8vIGxpbmtzIHZpYSB0aGUgZXF1aXZhbGVudCBvZiBhIGhhcmQgbmF2aWdhdGlvbiBhbmQgaGVuY2UgbmV2ZXIgdXRpbGl6ZSB0aGVzZVxuICAgICAgLy8gcHJlZmV0Y2hlcy5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG4gICAgY29uc3QgdXJsUGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcblxuICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkXG4gICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBwYXRobmFtZSA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lXG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcblxuICAgICAgICBsZXQgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aClcbiAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKFxuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICApXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgIGFzUGF0aCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcbiAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aFxuXG4gICAgY29uc3QgbG9jYWxlID1cbiAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWRcbiAgICAgICAgOiB0aGlzLmxvY2FsZVxuXG4gICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgIH0pXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICBsZXQgcmV3cml0ZXM6IGFueVxuICAgICAgOyh7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH0gPSBhd2FpdCBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpXG5cbiAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gcmVzb2x2ZVJld3JpdGVzKFxuICAgICAgICBhZGRCYXNlUGF0aChhZGRMb2NhbGUoYXNQYXRoLCB0aGlzLmxvY2FsZSksIHRydWUpLFxuICAgICAgICBwYWdlcyxcbiAgICAgICAgcmV3cml0ZXMsXG4gICAgICAgIHBhcnNlZC5xdWVyeSxcbiAgICAgICAgKHA6IHN0cmluZykgPT4gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuXG4gICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgIHJlc29sdmVkQXMgPSByZW1vdmVMb2NhbGUoXG4gICAgICAgICAgcmVtb3ZlQmFzZVBhdGgocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSxcbiAgICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZlxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuXG4gICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKVxuXG4gICAgaWYgKGlzRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSkpIHtcbiAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG4gICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGdldFJvdXRlTWF0Y2hlcihnZXRSb3V0ZVJlZ2V4KHBhcnNlZC5wYXRobmFtZSkpKFxuICAgICAgICAgIHBhcnNlUGF0aChhc1BhdGgpLnBhdGhuYW1lXG4gICAgICAgICkgfHwge31cbiAgICAgIClcblxuICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9XG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCA9PT0gJ3N0cmljdCdcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgIGZldGNoRGF0YTogKCkgPT5cbiAgICAgICAgICAgICAgZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICBocmVmOiBmb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBvcmlnaW5hbFBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICB9KVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgd2FzIGEgcmV3cml0ZSB3ZSBhcHBseSB0aGUgZWZmZWN0cyBvZiB0aGUgcmV3cml0ZSBvbiB0aGVcbiAgICAgKiBjdXJyZW50IHBhcmFtZXRlcnMgZm9yIHRoZSBwcmVmZXRjaC5cbiAgICAgKi9cbiAgICBpZiAoZGF0YT8uZWZmZWN0LnR5cGUgPT09ICdyZXdyaXRlJykge1xuICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmXG4gICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZlxuICAgICAgcXVlcnkgPSB7IC4uLnF1ZXJ5LCAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeSB9XG4gICAgICByZXNvbHZlZEFzID0gZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IHRvIGFuIGV4dGVybmFsIGRlc3RpbmF0aW9uIHRoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIHRvIHByZWZldGNoIGNvbnRlbnQgYXMgaXQgd2lsbCBiZSB1bnVzZWQuXG4gICAgICovXG4gICAgaWYgKGRhdGE/LmVmZmVjdC50eXBlID09PSAncmVkaXJlY3QtZXh0ZXJuYWwnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICBpZiAoYXdhaXQgdGhpcy5fYmZsKGFzUGF0aCwgcmVzb2x2ZWRBcywgb3B0aW9ucy5sb2NhbGUsIHRydWUpKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdXJsUGF0aG5hbWVdID0geyBfX2FwcFJvdXRlcjogdHJ1ZSB9IGFzIGFueVxuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKSA9PiB7XG4gICAgICAgIHJldHVybiBpc1NzZ1xuICAgICAgICAgID8gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgIGRhdGFIcmVmOiBkYXRhPy5qc29uXG4gICAgICAgICAgICAgICAgPyBkYXRhPy5kYXRhSHJlZlxuICAgICAgICAgICAgICAgIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTpcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB8fFxuICAgICAgICAgICAgICAgIChvcHRpb25zLnByaW9yaXR5ICYmXG4gICAgICAgICAgICAgICAgICAhIXByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAudGhlbigoKSA9PiBmYWxzZSlcbiAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKVxuICAgICAgICAgIDogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLFxuICAgIF0pXG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7IHJvdXRlLCByb3V0ZXI6IHRoaXMgfSlcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpXG4gICAgICBoYW5kbGVDYW5jZWxsZWQoKVxuXG4gICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBoYW5kbGVDYW5jZWxsZWQoKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgX2dldERhdGE8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfVxuICAgIHRoaXMuY2xjID0gY2FuY2VsXG4gICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKVxuICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgZ2V0SW5pdGlhbFByb3BzKFxuICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZSxcbiAgICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICApOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIGFueT4+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHAgYXMgQXBwQ29tcG9uZW50KVxuICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZVxuICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzPEFwcENvbnRleHRUeXBlPFJvdXRlcj4+KEFwcCwge1xuICAgICAgQXBwVHJlZSxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIGN0eCxcbiAgICB9KVxuICB9XG5cbiAgZ2V0IHJvdXRlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGVcbiAgfVxuXG4gIGdldCBwYXRobmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGhuYW1lXG4gIH1cblxuICBnZXQgcXVlcnkoKTogUGFyc2VkVXJsUXVlcnkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXJ5XG4gIH1cblxuICBnZXQgYXNQYXRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYXNQYXRoXG4gIH1cblxuICBnZXQgbG9jYWxlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlXG4gIH1cblxuICBnZXQgaXNGYWxsYmFjaygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZhbGxiYWNrXG4gIH1cblxuICBnZXQgaXNQcmV2aWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzUHJldmlld1xuICB9XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlS2V5IiwiUm91dGVyIiwibWF0Y2hlc01pZGRsZXdhcmUiLCJyZXNvbHZlUmV3cml0ZXMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0hBU19SRVdSSVRFUyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsIk9iamVjdCIsImFzc2lnbiIsIkVycm9yIiwiY2FuY2VsbGVkIiwib3B0aW9ucyIsIm1hdGNoZXJzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyb3V0ZXIiLCJwYWdlTG9hZGVyIiwiZ2V0TWlkZGxld2FyZSIsInBhdGhuYW1lIiwiYXNQYXRobmFtZSIsInBhcnNlUGF0aCIsImFzUGF0aCIsImNsZWFuZWRBcyIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwic29tZSIsIm0iLCJSZWdFeHAiLCJyZWdleHAiLCJ0ZXN0Iiwic3RyaXBPcmlnaW4iLCJ1cmwiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsImhyZWZXYXNBYnNvbHV0ZSIsImFzV2FzQWJzb2x1dGUiLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJpbmNsdWRlcyIsInBhZ2UiLCJpc0R5bmFtaWNSb3V0ZSIsImdldFJvdXRlUmVnZXgiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwiX19ORVhUX1RSQUlMSU5HX1NMQVNIIiwicmV3cml0ZUhlYWRlciIsImhlYWRlcnMiLCJnZXQiLCJyZXdyaXRlVGFyZ2V0IiwibWF0Y2hlZFBhdGgiLCJNQVRDSEVEX1BBVEhfSEVBREVSIiwiX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImFsbCIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJfX3Jld3JpdGVzIiwicmV3cml0ZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGFyc2VkU291cmNlIiwidW5kZWZpbmVkIiwicmVzdWx0IiwicXVlcnkiLCJwYXRoIiwibWF0Y2hlZFBhZ2UiLCJwYXJzZWRBcyIsInJlc29sdmVkUGF0aG5hbWUiLCJtYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwidHlwZSIsInNyYyIsImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJkZWZhdWx0TG9jYWxlIiwiYnVpbGRJZCIsImRlc3RpbmF0aW9uIiwiaGFzaCIsInJlZGlyZWN0VGFyZ2V0IiwibmV3QXMiLCJuZXdVcmwiLCJ3aXRoTWlkZGxld2FyZUVmZmVjdHMiLCJmZXRjaERhdGEiLCJkYXRhIiwiZWZmZWN0IiwiZGF0YUhyZWYiLCJqc29uIiwidGV4dCIsImNhY2hlS2V5IiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJfX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OIiwid2luZG93IiwiaGlzdG9yeSIsInYiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibiIsIlNTR19EQVRBX05PVF9GT1VORCIsIlN5bWJvbCIsImZldGNoUmV0cnkiLCJhdHRlbXB0cyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJtZXRob2QiLCJvayIsInN0YXR1cyIsInRyeVRvUGFyc2VBc0pTT04iLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImZldGNoTmV4dERhdGEiLCJpbmZsaWdodENhY2hlIiwiaXNQcmVmZXRjaCIsImhhc01pZGRsZXdhcmUiLCJpc1NlcnZlclJlbmRlciIsInBhcnNlSlNPTiIsInBlcnNpc3RDYWNoZSIsImlzQmFja2dyb3VuZCIsInVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSIsImhyZWYiLCJVUkwiLCJsb2NhdGlvbiIsImdldERhdGEiLCJwYXJhbXMiLCJwdXJwb3NlIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwibm90Rm91bmQiLCJtYXJrQXNzZXRFcnJvciIsIk5PREVfRU5WIiwiY2F0Y2giLCJlcnIiLCJtZXNzYWdlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsImV2ZW50cyIsIm1pdHQiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxQcm9wcyIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInNkYyIsInNiYyIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50IiwiX2tleSIsIm9uUG9wU3RhdGUiLCJlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZ2V0VVJMIiwiX19OQSIsInJlbG9hZCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImtleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsImF1dG9FeHBvcnREeW5hbWljIiwiX19ORVhUX0RBVEFfXyIsImF1dG9FeHBvcnQiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwic3ViIiwiX3dyYXBBcHAiLCJpc0xvY2FsZURvbWFpbiIsImlzUmVhZHkiLCJnc3NwIiwiZ2lwIiwiaXNFeHBlcmltZW50YWxDb21waWxlIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImRldGVjdERvbWFpbkxvY2FsZSIsImhvc3RuYW1lIiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJiYWNrIiwiZm9yd2FyZCIsInB1c2giLCJyZXBsYWNlIiwiX2JmbCIsInNraXBOYXZpZ2F0ZSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiX2JmbF9zIiwiX2JmbF9kIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiZHluYW1pY0ZpbHRlckRhdGEiLCJfX3JvdXRlckZpbHRlclN0YXRpYyIsIl9fcm91dGVyRmlsdGVyRHluYW1pYyIsImNvbnNvbGUiLCJyb3V0ZXJGaWx0ZXJTVmFsdWUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUiIsInJvdXRlckZpbHRlckRWYWx1ZSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwibnVtSGFzaGVzIiwibnVtSXRlbXMiLCJlcnJvclJhdGUiLCJpbXBvcnQiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJwYXRoc1RvQ2hlY2siLCJjdXJBcyIsImFsbG93TWF0Y2hDdXJyZW50IiwiYXNOb1NsYXNoIiwiYXNOb1NsYXNoTG9jYWxlIiwiY29udGFpbnMiLCJub3JtYWxpemVkQVMiLCJjdXJBc1BhcnRzIiwic3BsaXQiLCJpIiwiY3VycmVudFBhcnQiLCJqb2luIiwiaXNMb2NhbFVSTCIsImlzUXVlcnlVcGRhdGluZyIsInNob3VsZFJlc29sdmVIcmVmIiwibmV4dFN0YXRlIiwicmVhZHlTdGF0ZUNoYW5nZSIsInByZXZMb2NhbGUiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkaWROYXZpZ2F0ZSIsImRldGVjdGVkRG9tYWluIiwiZG9tYWluIiwiYXNOb0Jhc2VQYXRoIiwiaHR0cCIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwic2Nyb2xsIiwicm91dGVQcm9wcyIsIl9pbkZsaWdodFJvdXRlIiwiZW1pdCIsInJlbW92ZUxvY2FsZSIsImxvY2FsZUNoYW5nZSIsIm9ubHlBSGFzaENoYW5nZSIsInNjcm9sbFRvSGFzaCIsInNldCIsImlzRXJyb3IiLCJwYXJzZWQiLCJ1cmxJc05ldyIsInBhcnNlZEFzUGF0aG5hbWUiLCJfX2FwcFJvdXRlciIsImlzTWlkZGxld2FyZVJld3JpdGUiLCJpc01pZGRsZXdhcmVNYXRjaCIsInJld3JpdGVzUmVzdWx0IiwicCIsImV4dGVybmFsRGVzdCIsInJvdXRlTWF0Y2giLCJyb3V0ZVJlZ2V4Iiwic2hvdWxkSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJtaXNzaW5nUGFyYW1zIiwia2V5cyIsImdyb3VwcyIsImZpbHRlciIsInBhcmFtIiwib3B0aW9uYWwiLCJ3YXJuIiwib21pdCIsImlzRXJyb3JSb3V0ZSIsInJvdXRlSW5mbyIsImdldFJvdXRlSW5mbyIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsImZvckVhY2giLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsImNvbXBvbmVudCIsInVuc3RhYmxlX3NjcmlwdExvYWRlciIsInNjcmlwdHMiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX0JBU0VfUEFUSCIsInBhcnNlZEhyZWYiLCJfX05fUFJFVklFVyIsIm5vdEZvdW5kUm91dGUiLCJmZXRjaENvbXBvbmVudCIsIl8iLCJpc05vdEZvdW5kIiwic3RhdHVzQ29kZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJzaG91bGRTY3JvbGwiLCJyZXNldFNjcm9sbCIsInVwY29taW5nU2Nyb2xsU3RhdGUiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwiY2FuU2tpcFVwZGF0aW5nIiwiY29tcGFyZVJvdXRlclN0YXRlcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhc2hSZWdleCIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwibG9hZEVycm9yRmFpbCIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsImdpcEVyciIsInJvdXRlSW5mb0VyciIsInJlcXVlc3RlZFJvdXRlIiwiZXhpc3RpbmdJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiZmV0Y2hOZXh0RGF0YVBhcmFtcyIsImdldERhdGFIcmVmIiwic2tpcEludGVycG9sYXRpb24iLCJyZXNvbHZlZFJvdXRlIiwiaXNBUElSb3V0ZSIsInJlcyIsIm1vZCIsImlzVmFsaWRFbGVtZW50VHlwZSIsIndhc0JhaWxlZFByZWZldGNoIiwic2hvdWxkRmV0Y2hEYXRhIiwiX2dldERhdGEiLCJmZXRjaGVkIiwiZ2V0UHJvcGVyRXJyb3IiLCJiZWZvcmVQb3BTdGF0ZSIsImNiIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uIiwic2Nyb2xsVG8iLCJyYXdIYXNoIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWRFbCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsIm9ubHlIYXNoQ2hhbmdlIiwicHJlZmV0Y2giLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVybFBhdGhuYW1lIiwib3JpZ2luYWxQYXRobmFtZSIsIl9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIIiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsIl9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRSIsImNvbXBvbmVudFJlc3VsdCIsImxvYWRQYWdlIiwiZm4iLCJjdHgiLCJBcHBUcmVlIiwibG9hZEdldEluaXRpYWxQcm9wcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});